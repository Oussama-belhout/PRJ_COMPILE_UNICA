Grammaire

    0 $accept: programme $end

    1 programme: liste_declarations liste_fonctions

    2 liste_declarations: liste_declarations declaration
    3                   | declaration_fonction

    4 declaration_fonction: /* vide */
    5                     | declaration_fonction EXTERN type IDENTIFICATEUR LPAREN liste_parms RPAREN SEMICOLON

    6 liste_fonctions: liste_fonctions fonction
    7                | fonction

    8 declaration: type liste_declarateurs SEMICOLON

    9 liste_declarateurs: liste_declarateurs COMMA declarateur
   10                   | declarateur

   11 declarateur: IDENTIFICATEUR
   12            | declarateur LBRACKET CONSTANTE RBRACKET

   13 $@1: /* vide */

   14 $@2: /* vide */

   15 fonction: type IDENTIFICATEUR LPAREN liste_parms RPAREN $@1 bloc $@2

   16 type: VOID
   17     | INT

   18 liste_parms: liste_parms COMMA parm
   19            | parm
   20            | /* vide */

   21 parm: INT IDENTIFICATEUR

   22 liste_instructions: instruction liste_instructions
   23                   | /* vide */

   24 instruction: iteration
   25            | selection
   26            | saut
   27            | appel
   28            | affectation SEMICOLON

   29 $@3: /* vide */

   30 instruction: $@3 bloc

   31 iteration: FOR LPAREN affectation SEMICOLON condition SEMICOLON affectation RPAREN instruction
   32          | WHILE LPAREN condition RPAREN instruction

   33 selection: IF LPAREN condition RPAREN instruction
   34          | IF LPAREN condition RPAREN instruction ELSE instruction
   35          | SWITCH LPAREN expression RPAREN LBRACE switch_block RBRACE

   36 switch_block: cases default_case

   37 cases: /* vide */
   38      | cases CASE CONSTANTE COLON instruction

   39 default_case: /* vide */
   40             | DEFAULT COLON instruction

   41 appel: IDENTIFICATEUR LPAREN liste_expressions RPAREN SEMICOLON

   42 saut: BREAK SEMICOLON
   43     | RETURN SEMICOLON
   44     | RETURN expression SEMICOLON

   45 bloc: LBRACE liste_declarations liste_instructions RBRACE

   46 affectation: variable OP expression

   47 variable: var

   48 var: IDENTIFICATEUR
   49    | var LBRACKET expression RBRACKET

   50 expression: LPAREN expression RPAREN
   51           | expression binary_op expression
   52           | MOINS expression
   53           | CONSTANTE
   54           | variable
   55           | IDENTIFICATEUR LPAREN liste_expressions RPAREN

   56 liste_expressions: expression
   57                  | liste_expressions COMMA expression
   58                  | /* vide */

   59 condition: NOT LPAREN condition RPAREN
   60          | condition binary_rel condition
   61          | LPAREN condition RPAREN
   62          | expression binary_comp expression

   63 binary_op: PLUS
   64          | MOINS
   65          | MUL
   66          | DIV
   67          | LSHIFT
   68          | RSHIFT
   69          | BAND
   70          | BOR

   71 binary_rel: LAND
   72           | LOR

   73 binary_comp: LT
   74            | GT
   75            | GEQ
   76            | LEQ
   77            | EQ
   78            | NEQ


Terminaux, suivis des règles où ils apparaissent

$end (0) 0
error (256)
IDENTIFICATEUR (258) 5 11 15 21 41 48 55
CONSTANTE (259) 12 38 53
VOID (260) 16
INT (261) 17 21
FOR (262) 31
WHILE (263) 32
IF (264) 33 34
ELSE (265) 34
SWITCH (266) 35
CASE (267) 38
DEFAULT (268) 40
BREAK (269) 42
RETURN (270) 43 44
PLUS (271) 63
MOINS (272) 52 64
MUL (273) 65
DIV (274) 66
LSHIFT (275) 67
RSHIFT (276) 68
BAND (277) 69
BOR (278) 70
LAND (279) 71
LOR (280) 72
LT (281) 73
GT (282) 74
GEQ (283) 75
LEQ (284) 76
EQ (285) 77
NEQ (286) 78
NOT (287) 59
EXTERN (288) 5
LBRACE (289) 35 45
RBRACE (290) 35 45
LPAREN (291) 5 15 31 32 33 34 35 41 50 55 59 61
RPAREN (292) 5 15 31 32 33 34 35 41 50 55 59 61
COMMA (293) 9 18 57
LBRACKET (294) 12 49
RBRACKET (295) 12 49
SEMICOLON (296) 5 8 28 31 41 42 43 44
COLON (297) 38 40
THEN (298)
OP (299) 46
REL (300)


Non-terminaux, suivis des règles où ils apparaissent

$accept (46)
    à gauche: 0
programme (47)
    à gauche: 1, à droite: 0
liste_declarations (48)
    à gauche: 2 3, à droite: 1 2 45
declaration_fonction (49)
    à gauche: 4 5, à droite: 3 5
liste_fonctions (50)
    à gauche: 6 7, à droite: 1 6
declaration (51)
    à gauche: 8, à droite: 2
liste_declarateurs (52)
    à gauche: 9 10, à droite: 8 9
declarateur (53)
    à gauche: 11 12, à droite: 9 10 12
fonction (54)
    à gauche: 15, à droite: 6 7
$@1 (55)
    à gauche: 13, à droite: 15
$@2 (56)
    à gauche: 14, à droite: 15
type (57)
    à gauche: 16 17, à droite: 5 8 15
liste_parms (58)
    à gauche: 18 19 20, à droite: 5 15 18
parm (59)
    à gauche: 21, à droite: 18 19
liste_instructions (60)
    à gauche: 22 23, à droite: 22 45
instruction (61)
    à gauche: 24 25 26 27 28 30, à droite: 22 31 32 33 34 38 40
$@3 (62)
    à gauche: 29, à droite: 30
iteration (63)
    à gauche: 31 32, à droite: 24
selection (64)
    à gauche: 33 34 35, à droite: 25
switch_block (65)
    à gauche: 36, à droite: 35
cases (66)
    à gauche: 37 38, à droite: 36 38
default_case (67)
    à gauche: 39 40, à droite: 36
appel (68)
    à gauche: 41, à droite: 27
saut (69)
    à gauche: 42 43 44, à droite: 26
bloc (70)
    à gauche: 45, à droite: 15 30
affectation (71)
    à gauche: 46, à droite: 28 31
variable (72)
    à gauche: 47, à droite: 46 54
var (73)
    à gauche: 48 49, à droite: 47 49
expression (74)
    à gauche: 50 51 52 53 54 55, à droite: 35 44 46 49 50 51 52 56
    57 62
liste_expressions (75)
    à gauche: 56 57 58, à droite: 41 55 57
condition (76)
    à gauche: 59 60 61 62, à droite: 31 32 33 34 59 60 61
binary_op (77)
    à gauche: 63 64 65 66 67 68 69 70, à droite: 51
binary_rel (78)
    à gauche: 71 72, à droite: 60
binary_comp (79)
    à gauche: 73 74 75 76 77 78, à droite: 62


état 0

    0 $accept: . programme $end

    $défaut  réduction par utilisation de la règle 4 (declaration_fonction)

    programme             aller à l'état 1
    liste_declarations    aller à l'état 2
    declaration_fonction  aller à l'état 3


état 1

    0 $accept: programme . $end

    $end  décalage et aller à l'état 4


état 2

    1 programme: liste_declarations . liste_fonctions
    2 liste_declarations: liste_declarations . declaration

    VOID  décalage et aller à l'état 5
    INT   décalage et aller à l'état 6

    liste_fonctions  aller à l'état 7
    declaration      aller à l'état 8
    fonction         aller à l'état 9
    type             aller à l'état 10


état 3

    3 liste_declarations: declaration_fonction .
    5 declaration_fonction: declaration_fonction . EXTERN type IDENTIFICATEUR LPAREN liste_parms RPAREN SEMICOLON

    EXTERN  décalage et aller à l'état 11

    $défaut  réduction par utilisation de la règle 3 (liste_declarations)


état 4

    0 $accept: programme $end .

    $défaut  accepter


état 5

   16 type: VOID .

    $défaut  réduction par utilisation de la règle 16 (type)


état 6

   17 type: INT .

    $défaut  réduction par utilisation de la règle 17 (type)


état 7

    1 programme: liste_declarations liste_fonctions .
    6 liste_fonctions: liste_fonctions . fonction

    VOID  décalage et aller à l'état 5
    INT   décalage et aller à l'état 6

    $défaut  réduction par utilisation de la règle 1 (programme)

    fonction  aller à l'état 12
    type      aller à l'état 13


état 8

    2 liste_declarations: liste_declarations declaration .

    $défaut  réduction par utilisation de la règle 2 (liste_declarations)


état 9

    7 liste_fonctions: fonction .

    $défaut  réduction par utilisation de la règle 7 (liste_fonctions)


état 10

    8 declaration: type . liste_declarateurs SEMICOLON
   15 fonction: type . IDENTIFICATEUR LPAREN liste_parms RPAREN $@1 bloc $@2

    IDENTIFICATEUR  décalage et aller à l'état 14

    liste_declarateurs  aller à l'état 15
    declarateur         aller à l'état 16


état 11

    5 declaration_fonction: declaration_fonction EXTERN . type IDENTIFICATEUR LPAREN liste_parms RPAREN SEMICOLON

    VOID  décalage et aller à l'état 5
    INT   décalage et aller à l'état 6

    type  aller à l'état 17


état 12

    6 liste_fonctions: liste_fonctions fonction .

    $défaut  réduction par utilisation de la règle 6 (liste_fonctions)


état 13

   15 fonction: type . IDENTIFICATEUR LPAREN liste_parms RPAREN $@1 bloc $@2

    IDENTIFICATEUR  décalage et aller à l'état 18


état 14

   11 declarateur: IDENTIFICATEUR .
   15 fonction: type IDENTIFICATEUR . LPAREN liste_parms RPAREN $@1 bloc $@2

    LPAREN  décalage et aller à l'état 19

    $défaut  réduction par utilisation de la règle 11 (declarateur)


état 15

    8 declaration: type liste_declarateurs . SEMICOLON
    9 liste_declarateurs: liste_declarateurs . COMMA declarateur

    COMMA      décalage et aller à l'état 20
    SEMICOLON  décalage et aller à l'état 21


état 16

   10 liste_declarateurs: declarateur .
   12 declarateur: declarateur . LBRACKET CONSTANTE RBRACKET

    LBRACKET  décalage et aller à l'état 22

    $défaut  réduction par utilisation de la règle 10 (liste_declarateurs)


état 17

    5 declaration_fonction: declaration_fonction EXTERN type . IDENTIFICATEUR LPAREN liste_parms RPAREN SEMICOLON

    IDENTIFICATEUR  décalage et aller à l'état 23


état 18

   15 fonction: type IDENTIFICATEUR . LPAREN liste_parms RPAREN $@1 bloc $@2

    LPAREN  décalage et aller à l'état 19


état 19

   15 fonction: type IDENTIFICATEUR LPAREN . liste_parms RPAREN $@1 bloc $@2

    INT  décalage et aller à l'état 24

    $défaut  réduction par utilisation de la règle 20 (liste_parms)

    liste_parms  aller à l'état 25
    parm         aller à l'état 26


état 20

    9 liste_declarateurs: liste_declarateurs COMMA . declarateur

    IDENTIFICATEUR  décalage et aller à l'état 27

    declarateur  aller à l'état 28


état 21

    8 declaration: type liste_declarateurs SEMICOLON .

    $défaut  réduction par utilisation de la règle 8 (declaration)


état 22

   12 declarateur: declarateur LBRACKET . CONSTANTE RBRACKET

    CONSTANTE  décalage et aller à l'état 29


état 23

    5 declaration_fonction: declaration_fonction EXTERN type IDENTIFICATEUR . LPAREN liste_parms RPAREN SEMICOLON

    LPAREN  décalage et aller à l'état 30


état 24

   21 parm: INT . IDENTIFICATEUR

    IDENTIFICATEUR  décalage et aller à l'état 31


état 25

   15 fonction: type IDENTIFICATEUR LPAREN liste_parms . RPAREN $@1 bloc $@2
   18 liste_parms: liste_parms . COMMA parm

    RPAREN  décalage et aller à l'état 32
    COMMA   décalage et aller à l'état 33


état 26

   19 liste_parms: parm .

    $défaut  réduction par utilisation de la règle 19 (liste_parms)


état 27

   11 declarateur: IDENTIFICATEUR .

    $défaut  réduction par utilisation de la règle 11 (declarateur)


état 28

    9 liste_declarateurs: liste_declarateurs COMMA declarateur .
   12 declarateur: declarateur . LBRACKET CONSTANTE RBRACKET

    LBRACKET  décalage et aller à l'état 22

    $défaut  réduction par utilisation de la règle 9 (liste_declarateurs)


état 29

   12 declarateur: declarateur LBRACKET CONSTANTE . RBRACKET

    RBRACKET  décalage et aller à l'état 34


état 30

    5 declaration_fonction: declaration_fonction EXTERN type IDENTIFICATEUR LPAREN . liste_parms RPAREN SEMICOLON

    INT  décalage et aller à l'état 24

    $défaut  réduction par utilisation de la règle 20 (liste_parms)

    liste_parms  aller à l'état 35
    parm         aller à l'état 26


état 31

   21 parm: INT IDENTIFICATEUR .

    $défaut  réduction par utilisation de la règle 21 (parm)


état 32

   15 fonction: type IDENTIFICATEUR LPAREN liste_parms RPAREN . $@1 bloc $@2

    $défaut  réduction par utilisation de la règle 13 ($@1)

    $@1  aller à l'état 36


état 33

   18 liste_parms: liste_parms COMMA . parm

    INT  décalage et aller à l'état 24

    parm  aller à l'état 37


état 34

   12 declarateur: declarateur LBRACKET CONSTANTE RBRACKET .

    $défaut  réduction par utilisation de la règle 12 (declarateur)


état 35

    5 declaration_fonction: declaration_fonction EXTERN type IDENTIFICATEUR LPAREN liste_parms . RPAREN SEMICOLON
   18 liste_parms: liste_parms . COMMA parm

    RPAREN  décalage et aller à l'état 38
    COMMA   décalage et aller à l'état 33


état 36

   15 fonction: type IDENTIFICATEUR LPAREN liste_parms RPAREN $@1 . bloc $@2

    LBRACE  décalage et aller à l'état 39

    bloc  aller à l'état 40


état 37

   18 liste_parms: liste_parms COMMA parm .

    $défaut  réduction par utilisation de la règle 18 (liste_parms)


état 38

    5 declaration_fonction: declaration_fonction EXTERN type IDENTIFICATEUR LPAREN liste_parms RPAREN . SEMICOLON

    SEMICOLON  décalage et aller à l'état 41


état 39

   45 bloc: LBRACE . liste_declarations liste_instructions RBRACE

    $défaut  réduction par utilisation de la règle 4 (declaration_fonction)

    liste_declarations    aller à l'état 42
    declaration_fonction  aller à l'état 3


état 40

   15 fonction: type IDENTIFICATEUR LPAREN liste_parms RPAREN $@1 bloc . $@2

    $défaut  réduction par utilisation de la règle 14 ($@2)

    $@2  aller à l'état 43


état 41

    5 declaration_fonction: declaration_fonction EXTERN type IDENTIFICATEUR LPAREN liste_parms RPAREN SEMICOLON .

    $défaut  réduction par utilisation de la règle 5 (declaration_fonction)


état 42

    2 liste_declarations: liste_declarations . declaration
   45 bloc: LBRACE liste_declarations . liste_instructions RBRACE

    IDENTIFICATEUR  décalage et aller à l'état 44
    VOID            décalage et aller à l'état 5
    INT             décalage et aller à l'état 6
    FOR             décalage et aller à l'état 45
    WHILE           décalage et aller à l'état 46
    IF              décalage et aller à l'état 47
    SWITCH          décalage et aller à l'état 48
    BREAK           décalage et aller à l'état 49
    RETURN          décalage et aller à l'état 50

    LBRACE   réduction par utilisation de la règle 29 ($@3)
    $défaut  réduction par utilisation de la règle 23 (liste_instructions)

    declaration         aller à l'état 8
    type                aller à l'état 51
    liste_instructions  aller à l'état 52
    instruction         aller à l'état 53
    $@3                 aller à l'état 54
    iteration           aller à l'état 55
    selection           aller à l'état 56
    appel               aller à l'état 57
    saut                aller à l'état 58
    affectation         aller à l'état 59
    variable            aller à l'état 60
    var                 aller à l'état 61


état 43

   15 fonction: type IDENTIFICATEUR LPAREN liste_parms RPAREN $@1 bloc $@2 .

    $défaut  réduction par utilisation de la règle 15 (fonction)


état 44

   41 appel: IDENTIFICATEUR . LPAREN liste_expressions RPAREN SEMICOLON
   48 var: IDENTIFICATEUR .

    LPAREN  décalage et aller à l'état 62

    $défaut  réduction par utilisation de la règle 48 (var)


état 45

   31 iteration: FOR . LPAREN affectation SEMICOLON condition SEMICOLON affectation RPAREN instruction

    LPAREN  décalage et aller à l'état 63


état 46

   32 iteration: WHILE . LPAREN condition RPAREN instruction

    LPAREN  décalage et aller à l'état 64


état 47

   33 selection: IF . LPAREN condition RPAREN instruction
   34          | IF . LPAREN condition RPAREN instruction ELSE instruction

    LPAREN  décalage et aller à l'état 65


état 48

   35 selection: SWITCH . LPAREN expression RPAREN LBRACE switch_block RBRACE

    LPAREN  décalage et aller à l'état 66


état 49

   42 saut: BREAK . SEMICOLON

    SEMICOLON  décalage et aller à l'état 67


état 50

   43 saut: RETURN . SEMICOLON
   44     | RETURN . expression SEMICOLON

    IDENTIFICATEUR  décalage et aller à l'état 68
    CONSTANTE       décalage et aller à l'état 69
    MOINS           décalage et aller à l'état 70
    LPAREN          décalage et aller à l'état 71
    SEMICOLON       décalage et aller à l'état 72

    variable    aller à l'état 73
    var         aller à l'état 61
    expression  aller à l'état 74


état 51

    8 declaration: type . liste_declarateurs SEMICOLON

    IDENTIFICATEUR  décalage et aller à l'état 27

    liste_declarateurs  aller à l'état 15
    declarateur         aller à l'état 16


état 52

   45 bloc: LBRACE liste_declarations liste_instructions . RBRACE

    RBRACE  décalage et aller à l'état 75


état 53

   22 liste_instructions: instruction . liste_instructions

    IDENTIFICATEUR  décalage et aller à l'état 44
    FOR             décalage et aller à l'état 45
    WHILE           décalage et aller à l'état 46
    IF              décalage et aller à l'état 47
    SWITCH          décalage et aller à l'état 48
    BREAK           décalage et aller à l'état 49
    RETURN          décalage et aller à l'état 50

    LBRACE   réduction par utilisation de la règle 29 ($@3)
    $défaut  réduction par utilisation de la règle 23 (liste_instructions)

    liste_instructions  aller à l'état 76
    instruction         aller à l'état 53
    $@3                 aller à l'état 54
    iteration           aller à l'état 55
    selection           aller à l'état 56
    appel               aller à l'état 57
    saut                aller à l'état 58
    affectation         aller à l'état 59
    variable            aller à l'état 60
    var                 aller à l'état 61


état 54

   30 instruction: $@3 . bloc

    LBRACE  décalage et aller à l'état 39

    bloc  aller à l'état 77


état 55

   24 instruction: iteration .

    $défaut  réduction par utilisation de la règle 24 (instruction)


état 56

   25 instruction: selection .

    $défaut  réduction par utilisation de la règle 25 (instruction)


état 57

   27 instruction: appel .

    $défaut  réduction par utilisation de la règle 27 (instruction)


état 58

   26 instruction: saut .

    $défaut  réduction par utilisation de la règle 26 (instruction)


état 59

   28 instruction: affectation . SEMICOLON

    SEMICOLON  décalage et aller à l'état 78


état 60

   46 affectation: variable . OP expression

    OP  décalage et aller à l'état 79


état 61

   47 variable: var .
   49 var: var . LBRACKET expression RBRACKET

    LBRACKET  décalage et aller à l'état 80

    $défaut  réduction par utilisation de la règle 47 (variable)


état 62

   41 appel: IDENTIFICATEUR LPAREN . liste_expressions RPAREN SEMICOLON

    IDENTIFICATEUR  décalage et aller à l'état 68
    CONSTANTE       décalage et aller à l'état 69
    MOINS           décalage et aller à l'état 70
    LPAREN          décalage et aller à l'état 71

    $défaut  réduction par utilisation de la règle 58 (liste_expressions)

    variable           aller à l'état 73
    var                aller à l'état 61
    expression         aller à l'état 81
    liste_expressions  aller à l'état 82


état 63

   31 iteration: FOR LPAREN . affectation SEMICOLON condition SEMICOLON affectation RPAREN instruction

    IDENTIFICATEUR  décalage et aller à l'état 83

    affectation  aller à l'état 84
    variable     aller à l'état 60
    var          aller à l'état 61


état 64

   32 iteration: WHILE LPAREN . condition RPAREN instruction

    IDENTIFICATEUR  décalage et aller à l'état 68
    CONSTANTE       décalage et aller à l'état 69
    MOINS           décalage et aller à l'état 70
    NOT             décalage et aller à l'état 85
    LPAREN          décalage et aller à l'état 86

    variable    aller à l'état 73
    var         aller à l'état 61
    expression  aller à l'état 87
    condition   aller à l'état 88


état 65

   33 selection: IF LPAREN . condition RPAREN instruction
   34          | IF LPAREN . condition RPAREN instruction ELSE instruction

    IDENTIFICATEUR  décalage et aller à l'état 68
    CONSTANTE       décalage et aller à l'état 69
    MOINS           décalage et aller à l'état 70
    NOT             décalage et aller à l'état 85
    LPAREN          décalage et aller à l'état 86

    variable    aller à l'état 73
    var         aller à l'état 61
    expression  aller à l'état 87
    condition   aller à l'état 89


état 66

   35 selection: SWITCH LPAREN . expression RPAREN LBRACE switch_block RBRACE

    IDENTIFICATEUR  décalage et aller à l'état 68
    CONSTANTE       décalage et aller à l'état 69
    MOINS           décalage et aller à l'état 70
    LPAREN          décalage et aller à l'état 71

    variable    aller à l'état 73
    var         aller à l'état 61
    expression  aller à l'état 90


état 67

   42 saut: BREAK SEMICOLON .

    $défaut  réduction par utilisation de la règle 42 (saut)


état 68

   48 var: IDENTIFICATEUR .
   55 expression: IDENTIFICATEUR . LPAREN liste_expressions RPAREN

    LPAREN  décalage et aller à l'état 91

    $défaut  réduction par utilisation de la règle 48 (var)


état 69

   53 expression: CONSTANTE .

    $défaut  réduction par utilisation de la règle 53 (expression)


état 70

   52 expression: MOINS . expression

    IDENTIFICATEUR  décalage et aller à l'état 68
    CONSTANTE       décalage et aller à l'état 69
    MOINS           décalage et aller à l'état 70
    LPAREN          décalage et aller à l'état 71

    variable    aller à l'état 73
    var         aller à l'état 61
    expression  aller à l'état 92


état 71

   50 expression: LPAREN . expression RPAREN

    IDENTIFICATEUR  décalage et aller à l'état 68
    CONSTANTE       décalage et aller à l'état 69
    MOINS           décalage et aller à l'état 70
    LPAREN          décalage et aller à l'état 71

    variable    aller à l'état 73
    var         aller à l'état 61
    expression  aller à l'état 93


état 72

   43 saut: RETURN SEMICOLON .

    $défaut  réduction par utilisation de la règle 43 (saut)


état 73

   54 expression: variable .

    $défaut  réduction par utilisation de la règle 54 (expression)


état 74

   44 saut: RETURN expression . SEMICOLON
   51 expression: expression . binary_op expression

    PLUS       décalage et aller à l'état 94
    MOINS      décalage et aller à l'état 95
    MUL        décalage et aller à l'état 96
    DIV        décalage et aller à l'état 97
    LSHIFT     décalage et aller à l'état 98
    RSHIFT     décalage et aller à l'état 99
    BAND       décalage et aller à l'état 100
    BOR        décalage et aller à l'état 101
    SEMICOLON  décalage et aller à l'état 102

    binary_op  aller à l'état 103


état 75

   45 bloc: LBRACE liste_declarations liste_instructions RBRACE .

    $défaut  réduction par utilisation de la règle 45 (bloc)


état 76

   22 liste_instructions: instruction liste_instructions .

    $défaut  réduction par utilisation de la règle 22 (liste_instructions)


état 77

   30 instruction: $@3 bloc .

    $défaut  réduction par utilisation de la règle 30 (instruction)


état 78

   28 instruction: affectation SEMICOLON .

    $défaut  réduction par utilisation de la règle 28 (instruction)


état 79

   46 affectation: variable OP . expression

    IDENTIFICATEUR  décalage et aller à l'état 68
    CONSTANTE       décalage et aller à l'état 69
    MOINS           décalage et aller à l'état 70
    LPAREN          décalage et aller à l'état 71

    variable    aller à l'état 73
    var         aller à l'état 61
    expression  aller à l'état 104


état 80

   49 var: var LBRACKET . expression RBRACKET

    IDENTIFICATEUR  décalage et aller à l'état 68
    CONSTANTE       décalage et aller à l'état 69
    MOINS           décalage et aller à l'état 70
    LPAREN          décalage et aller à l'état 71

    variable    aller à l'état 73
    var         aller à l'état 61
    expression  aller à l'état 105


état 81

   51 expression: expression . binary_op expression
   56 liste_expressions: expression .

    PLUS    décalage et aller à l'état 94
    MOINS   décalage et aller à l'état 95
    MUL     décalage et aller à l'état 96
    DIV     décalage et aller à l'état 97
    LSHIFT  décalage et aller à l'état 98
    RSHIFT  décalage et aller à l'état 99
    BAND    décalage et aller à l'état 100
    BOR     décalage et aller à l'état 101

    $défaut  réduction par utilisation de la règle 56 (liste_expressions)

    binary_op  aller à l'état 103


état 82

   41 appel: IDENTIFICATEUR LPAREN liste_expressions . RPAREN SEMICOLON
   57 liste_expressions: liste_expressions . COMMA expression

    RPAREN  décalage et aller à l'état 106
    COMMA   décalage et aller à l'état 107


état 83

   48 var: IDENTIFICATEUR .

    $défaut  réduction par utilisation de la règle 48 (var)


état 84

   31 iteration: FOR LPAREN affectation . SEMICOLON condition SEMICOLON affectation RPAREN instruction

    SEMICOLON  décalage et aller à l'état 108


état 85

   59 condition: NOT . LPAREN condition RPAREN

    LPAREN  décalage et aller à l'état 109


état 86

   50 expression: LPAREN . expression RPAREN
   61 condition: LPAREN . condition RPAREN

    IDENTIFICATEUR  décalage et aller à l'état 68
    CONSTANTE       décalage et aller à l'état 69
    MOINS           décalage et aller à l'état 70
    NOT             décalage et aller à l'état 85
    LPAREN          décalage et aller à l'état 86

    variable    aller à l'état 73
    var         aller à l'état 61
    expression  aller à l'état 110
    condition   aller à l'état 111


état 87

   51 expression: expression . binary_op expression
   62 condition: expression . binary_comp expression

    PLUS    décalage et aller à l'état 94
    MOINS   décalage et aller à l'état 95
    MUL     décalage et aller à l'état 96
    DIV     décalage et aller à l'état 97
    LSHIFT  décalage et aller à l'état 98
    RSHIFT  décalage et aller à l'état 99
    BAND    décalage et aller à l'état 100
    BOR     décalage et aller à l'état 101
    LT      décalage et aller à l'état 112
    GT      décalage et aller à l'état 113
    GEQ     décalage et aller à l'état 114
    LEQ     décalage et aller à l'état 115
    EQ      décalage et aller à l'état 116
    NEQ     décalage et aller à l'état 117

    binary_op    aller à l'état 103
    binary_comp  aller à l'état 118


état 88

   32 iteration: WHILE LPAREN condition . RPAREN instruction
   60 condition: condition . binary_rel condition

    LAND    décalage et aller à l'état 119
    LOR     décalage et aller à l'état 120
    RPAREN  décalage et aller à l'état 121

    binary_rel  aller à l'état 122


état 89

   33 selection: IF LPAREN condition . RPAREN instruction
   34          | IF LPAREN condition . RPAREN instruction ELSE instruction
   60 condition: condition . binary_rel condition

    LAND    décalage et aller à l'état 119
    LOR     décalage et aller à l'état 120
    RPAREN  décalage et aller à l'état 123

    binary_rel  aller à l'état 122


état 90

   35 selection: SWITCH LPAREN expression . RPAREN LBRACE switch_block RBRACE
   51 expression: expression . binary_op expression

    PLUS    décalage et aller à l'état 94
    MOINS   décalage et aller à l'état 95
    MUL     décalage et aller à l'état 96
    DIV     décalage et aller à l'état 97
    LSHIFT  décalage et aller à l'état 98
    RSHIFT  décalage et aller à l'état 99
    BAND    décalage et aller à l'état 100
    BOR     décalage et aller à l'état 101
    RPAREN  décalage et aller à l'état 124

    binary_op  aller à l'état 103


état 91

   55 expression: IDENTIFICATEUR LPAREN . liste_expressions RPAREN

    IDENTIFICATEUR  décalage et aller à l'état 68
    CONSTANTE       décalage et aller à l'état 69
    MOINS           décalage et aller à l'état 70
    LPAREN          décalage et aller à l'état 71

    $défaut  réduction par utilisation de la règle 58 (liste_expressions)

    variable           aller à l'état 73
    var                aller à l'état 61
    expression         aller à l'état 81
    liste_expressions  aller à l'état 125


état 92

   51 expression: expression . binary_op expression
   52           | MOINS expression .

    MUL     décalage et aller à l'état 96
    DIV     décalage et aller à l'état 97
    LSHIFT  décalage et aller à l'état 98
    RSHIFT  décalage et aller à l'état 99
    BAND    décalage et aller à l'état 100
    BOR     décalage et aller à l'état 101

    $défaut  réduction par utilisation de la règle 52 (expression)

    binary_op  aller à l'état 103


état 93

   50 expression: LPAREN expression . RPAREN
   51           | expression . binary_op expression

    PLUS    décalage et aller à l'état 94
    MOINS   décalage et aller à l'état 95
    MUL     décalage et aller à l'état 96
    DIV     décalage et aller à l'état 97
    LSHIFT  décalage et aller à l'état 98
    RSHIFT  décalage et aller à l'état 99
    BAND    décalage et aller à l'état 100
    BOR     décalage et aller à l'état 101
    RPAREN  décalage et aller à l'état 126

    binary_op  aller à l'état 103


état 94

   63 binary_op: PLUS .

    $défaut  réduction par utilisation de la règle 63 (binary_op)


état 95

   64 binary_op: MOINS .

    $défaut  réduction par utilisation de la règle 64 (binary_op)


état 96

   65 binary_op: MUL .

    $défaut  réduction par utilisation de la règle 65 (binary_op)


état 97

   66 binary_op: DIV .

    $défaut  réduction par utilisation de la règle 66 (binary_op)


état 98

   67 binary_op: LSHIFT .

    $défaut  réduction par utilisation de la règle 67 (binary_op)


état 99

   68 binary_op: RSHIFT .

    $défaut  réduction par utilisation de la règle 68 (binary_op)


état 100

   69 binary_op: BAND .

    $défaut  réduction par utilisation de la règle 69 (binary_op)


état 101

   70 binary_op: BOR .

    $défaut  réduction par utilisation de la règle 70 (binary_op)


état 102

   44 saut: RETURN expression SEMICOLON .

    $défaut  réduction par utilisation de la règle 44 (saut)


état 103

   51 expression: expression binary_op . expression

    IDENTIFICATEUR  décalage et aller à l'état 68
    CONSTANTE       décalage et aller à l'état 69
    MOINS           décalage et aller à l'état 70
    LPAREN          décalage et aller à l'état 71

    variable    aller à l'état 73
    var         aller à l'état 61
    expression  aller à l'état 127


état 104

   46 affectation: variable OP expression .
   51 expression: expression . binary_op expression

    PLUS    décalage et aller à l'état 94
    MOINS   décalage et aller à l'état 95
    MUL     décalage et aller à l'état 96
    DIV     décalage et aller à l'état 97
    LSHIFT  décalage et aller à l'état 98
    RSHIFT  décalage et aller à l'état 99
    BAND    décalage et aller à l'état 100
    BOR     décalage et aller à l'état 101

    $défaut  réduction par utilisation de la règle 46 (affectation)

    binary_op  aller à l'état 103


état 105

   49 var: var LBRACKET expression . RBRACKET
   51 expression: expression . binary_op expression

    PLUS      décalage et aller à l'état 94
    MOINS     décalage et aller à l'état 95
    MUL       décalage et aller à l'état 96
    DIV       décalage et aller à l'état 97
    LSHIFT    décalage et aller à l'état 98
    RSHIFT    décalage et aller à l'état 99
    BAND      décalage et aller à l'état 100
    BOR       décalage et aller à l'état 101
    RBRACKET  décalage et aller à l'état 128

    binary_op  aller à l'état 103


état 106

   41 appel: IDENTIFICATEUR LPAREN liste_expressions RPAREN . SEMICOLON

    SEMICOLON  décalage et aller à l'état 129


état 107

   57 liste_expressions: liste_expressions COMMA . expression

    IDENTIFICATEUR  décalage et aller à l'état 68
    CONSTANTE       décalage et aller à l'état 69
    MOINS           décalage et aller à l'état 70
    LPAREN          décalage et aller à l'état 71

    variable    aller à l'état 73
    var         aller à l'état 61
    expression  aller à l'état 130


état 108

   31 iteration: FOR LPAREN affectation SEMICOLON . condition SEMICOLON affectation RPAREN instruction

    IDENTIFICATEUR  décalage et aller à l'état 68
    CONSTANTE       décalage et aller à l'état 69
    MOINS           décalage et aller à l'état 70
    NOT             décalage et aller à l'état 85
    LPAREN          décalage et aller à l'état 86

    variable    aller à l'état 73
    var         aller à l'état 61
    expression  aller à l'état 87
    condition   aller à l'état 131


état 109

   59 condition: NOT LPAREN . condition RPAREN

    IDENTIFICATEUR  décalage et aller à l'état 68
    CONSTANTE       décalage et aller à l'état 69
    MOINS           décalage et aller à l'état 70
    NOT             décalage et aller à l'état 85
    LPAREN          décalage et aller à l'état 86

    variable    aller à l'état 73
    var         aller à l'état 61
    expression  aller à l'état 87
    condition   aller à l'état 132


état 110

   50 expression: LPAREN expression . RPAREN
   51           | expression . binary_op expression
   62 condition: expression . binary_comp expression

    PLUS    décalage et aller à l'état 94
    MOINS   décalage et aller à l'état 95
    MUL     décalage et aller à l'état 96
    DIV     décalage et aller à l'état 97
    LSHIFT  décalage et aller à l'état 98
    RSHIFT  décalage et aller à l'état 99
    BAND    décalage et aller à l'état 100
    BOR     décalage et aller à l'état 101
    LT      décalage et aller à l'état 112
    GT      décalage et aller à l'état 113
    GEQ     décalage et aller à l'état 114
    LEQ     décalage et aller à l'état 115
    EQ      décalage et aller à l'état 116
    NEQ     décalage et aller à l'état 117
    RPAREN  décalage et aller à l'état 126

    binary_op    aller à l'état 103
    binary_comp  aller à l'état 118


état 111

   60 condition: condition . binary_rel condition
   61          | LPAREN condition . RPAREN

    LAND    décalage et aller à l'état 119
    LOR     décalage et aller à l'état 120
    RPAREN  décalage et aller à l'état 133

    binary_rel  aller à l'état 122


état 112

   73 binary_comp: LT .

    $défaut  réduction par utilisation de la règle 73 (binary_comp)


état 113

   74 binary_comp: GT .

    $défaut  réduction par utilisation de la règle 74 (binary_comp)


état 114

   75 binary_comp: GEQ .

    $défaut  réduction par utilisation de la règle 75 (binary_comp)


état 115

   76 binary_comp: LEQ .

    $défaut  réduction par utilisation de la règle 76 (binary_comp)


état 116

   77 binary_comp: EQ .

    $défaut  réduction par utilisation de la règle 77 (binary_comp)


état 117

   78 binary_comp: NEQ .

    $défaut  réduction par utilisation de la règle 78 (binary_comp)


état 118

   62 condition: expression binary_comp . expression

    IDENTIFICATEUR  décalage et aller à l'état 68
    CONSTANTE       décalage et aller à l'état 69
    MOINS           décalage et aller à l'état 70
    LPAREN          décalage et aller à l'état 71

    variable    aller à l'état 73
    var         aller à l'état 61
    expression  aller à l'état 134


état 119

   71 binary_rel: LAND .

    $défaut  réduction par utilisation de la règle 71 (binary_rel)


état 120

   72 binary_rel: LOR .

    $défaut  réduction par utilisation de la règle 72 (binary_rel)


état 121

   32 iteration: WHILE LPAREN condition RPAREN . instruction

    IDENTIFICATEUR  décalage et aller à l'état 44
    FOR             décalage et aller à l'état 45
    WHILE           décalage et aller à l'état 46
    IF              décalage et aller à l'état 47
    SWITCH          décalage et aller à l'état 48
    BREAK           décalage et aller à l'état 49
    RETURN          décalage et aller à l'état 50

    $défaut  réduction par utilisation de la règle 29 ($@3)

    instruction  aller à l'état 135
    $@3          aller à l'état 54
    iteration    aller à l'état 55
    selection    aller à l'état 56
    appel        aller à l'état 57
    saut         aller à l'état 58
    affectation  aller à l'état 59
    variable     aller à l'état 60
    var          aller à l'état 61


état 122

   60 condition: condition binary_rel . condition

    IDENTIFICATEUR  décalage et aller à l'état 68
    CONSTANTE       décalage et aller à l'état 69
    MOINS           décalage et aller à l'état 70
    NOT             décalage et aller à l'état 85
    LPAREN          décalage et aller à l'état 86

    variable    aller à l'état 73
    var         aller à l'état 61
    expression  aller à l'état 87
    condition   aller à l'état 136


état 123

   33 selection: IF LPAREN condition RPAREN . instruction
   34          | IF LPAREN condition RPAREN . instruction ELSE instruction

    IDENTIFICATEUR  décalage et aller à l'état 44
    FOR             décalage et aller à l'état 45
    WHILE           décalage et aller à l'état 46
    IF              décalage et aller à l'état 47
    SWITCH          décalage et aller à l'état 48
    BREAK           décalage et aller à l'état 49
    RETURN          décalage et aller à l'état 50

    $défaut  réduction par utilisation de la règle 29 ($@3)

    instruction  aller à l'état 137
    $@3          aller à l'état 54
    iteration    aller à l'état 55
    selection    aller à l'état 56
    appel        aller à l'état 57
    saut         aller à l'état 58
    affectation  aller à l'état 59
    variable     aller à l'état 60
    var          aller à l'état 61


état 124

   35 selection: SWITCH LPAREN expression RPAREN . LBRACE switch_block RBRACE

    LBRACE  décalage et aller à l'état 138


état 125

   55 expression: IDENTIFICATEUR LPAREN liste_expressions . RPAREN
   57 liste_expressions: liste_expressions . COMMA expression

    RPAREN  décalage et aller à l'état 139
    COMMA   décalage et aller à l'état 107


état 126

   50 expression: LPAREN expression RPAREN .

    $défaut  réduction par utilisation de la règle 50 (expression)


état 127

   51 expression: expression . binary_op expression
   51           | expression binary_op expression .

    $défaut  réduction par utilisation de la règle 51 (expression)

    binary_op  aller à l'état 103


état 128

   49 var: var LBRACKET expression RBRACKET .

    $défaut  réduction par utilisation de la règle 49 (var)


état 129

   41 appel: IDENTIFICATEUR LPAREN liste_expressions RPAREN SEMICOLON .

    $défaut  réduction par utilisation de la règle 41 (appel)


état 130

   51 expression: expression . binary_op expression
   57 liste_expressions: liste_expressions COMMA expression .

    PLUS    décalage et aller à l'état 94
    MOINS   décalage et aller à l'état 95
    MUL     décalage et aller à l'état 96
    DIV     décalage et aller à l'état 97
    LSHIFT  décalage et aller à l'état 98
    RSHIFT  décalage et aller à l'état 99
    BAND    décalage et aller à l'état 100
    BOR     décalage et aller à l'état 101

    $défaut  réduction par utilisation de la règle 57 (liste_expressions)

    binary_op  aller à l'état 103


état 131

   31 iteration: FOR LPAREN affectation SEMICOLON condition . SEMICOLON affectation RPAREN instruction
   60 condition: condition . binary_rel condition

    LAND       décalage et aller à l'état 119
    LOR        décalage et aller à l'état 120
    SEMICOLON  décalage et aller à l'état 140

    binary_rel  aller à l'état 122


état 132

   59 condition: NOT LPAREN condition . RPAREN
   60          | condition . binary_rel condition

    LAND    décalage et aller à l'état 119
    LOR     décalage et aller à l'état 120
    RPAREN  décalage et aller à l'état 141

    binary_rel  aller à l'état 122


état 133

   61 condition: LPAREN condition RPAREN .

    $défaut  réduction par utilisation de la règle 61 (condition)


état 134

   51 expression: expression . binary_op expression
   62 condition: expression binary_comp expression .

    PLUS    décalage et aller à l'état 94
    MOINS   décalage et aller à l'état 95
    MUL     décalage et aller à l'état 96
    DIV     décalage et aller à l'état 97
    LSHIFT  décalage et aller à l'état 98
    RSHIFT  décalage et aller à l'état 99
    BAND    décalage et aller à l'état 100
    BOR     décalage et aller à l'état 101

    $défaut  réduction par utilisation de la règle 62 (condition)

    binary_op  aller à l'état 103


état 135

   32 iteration: WHILE LPAREN condition RPAREN instruction .

    $défaut  réduction par utilisation de la règle 32 (iteration)


état 136

   60 condition: condition . binary_rel condition
   60          | condition binary_rel condition .

    $défaut  réduction par utilisation de la règle 60 (condition)

    binary_rel  aller à l'état 122


état 137

   33 selection: IF LPAREN condition RPAREN instruction .
   34          | IF LPAREN condition RPAREN instruction . ELSE instruction

    ELSE  décalage et aller à l'état 142

    $défaut  réduction par utilisation de la règle 33 (selection)


état 138

   35 selection: SWITCH LPAREN expression RPAREN LBRACE . switch_block RBRACE

    $défaut  réduction par utilisation de la règle 37 (cases)

    switch_block  aller à l'état 143
    cases         aller à l'état 144


état 139

   55 expression: IDENTIFICATEUR LPAREN liste_expressions RPAREN .

    $défaut  réduction par utilisation de la règle 55 (expression)


état 140

   31 iteration: FOR LPAREN affectation SEMICOLON condition SEMICOLON . affectation RPAREN instruction

    IDENTIFICATEUR  décalage et aller à l'état 83

    affectation  aller à l'état 145
    variable     aller à l'état 60
    var          aller à l'état 61


état 141

   59 condition: NOT LPAREN condition RPAREN .

    $défaut  réduction par utilisation de la règle 59 (condition)


état 142

   34 selection: IF LPAREN condition RPAREN instruction ELSE . instruction

    IDENTIFICATEUR  décalage et aller à l'état 44
    FOR             décalage et aller à l'état 45
    WHILE           décalage et aller à l'état 46
    IF              décalage et aller à l'état 47
    SWITCH          décalage et aller à l'état 48
    BREAK           décalage et aller à l'état 49
    RETURN          décalage et aller à l'état 50

    $défaut  réduction par utilisation de la règle 29 ($@3)

    instruction  aller à l'état 146
    $@3          aller à l'état 54
    iteration    aller à l'état 55
    selection    aller à l'état 56
    appel        aller à l'état 57
    saut         aller à l'état 58
    affectation  aller à l'état 59
    variable     aller à l'état 60
    var          aller à l'état 61


état 143

   35 selection: SWITCH LPAREN expression RPAREN LBRACE switch_block . RBRACE

    RBRACE  décalage et aller à l'état 147


état 144

   36 switch_block: cases . default_case
   38 cases: cases . CASE CONSTANTE COLON instruction

    CASE     décalage et aller à l'état 148
    DEFAULT  décalage et aller à l'état 149

    $défaut  réduction par utilisation de la règle 39 (default_case)

    default_case  aller à l'état 150


état 145

   31 iteration: FOR LPAREN affectation SEMICOLON condition SEMICOLON affectation . RPAREN instruction

    RPAREN  décalage et aller à l'état 151


état 146

   34 selection: IF LPAREN condition RPAREN instruction ELSE instruction .

    $défaut  réduction par utilisation de la règle 34 (selection)


état 147

   35 selection: SWITCH LPAREN expression RPAREN LBRACE switch_block RBRACE .

    $défaut  réduction par utilisation de la règle 35 (selection)


état 148

   38 cases: cases CASE . CONSTANTE COLON instruction

    CONSTANTE  décalage et aller à l'état 152


état 149

   40 default_case: DEFAULT . COLON instruction

    COLON  décalage et aller à l'état 153


état 150

   36 switch_block: cases default_case .

    $défaut  réduction par utilisation de la règle 36 (switch_block)


état 151

   31 iteration: FOR LPAREN affectation SEMICOLON condition SEMICOLON affectation RPAREN . instruction

    IDENTIFICATEUR  décalage et aller à l'état 44
    FOR             décalage et aller à l'état 45
    WHILE           décalage et aller à l'état 46
    IF              décalage et aller à l'état 47
    SWITCH          décalage et aller à l'état 48
    BREAK           décalage et aller à l'état 49
    RETURN          décalage et aller à l'état 50

    $défaut  réduction par utilisation de la règle 29 ($@3)

    instruction  aller à l'état 154
    $@3          aller à l'état 54
    iteration    aller à l'état 55
    selection    aller à l'état 56
    appel        aller à l'état 57
    saut         aller à l'état 58
    affectation  aller à l'état 59
    variable     aller à l'état 60
    var          aller à l'état 61


état 152

   38 cases: cases CASE CONSTANTE . COLON instruction

    COLON  décalage et aller à l'état 155


état 153

   40 default_case: DEFAULT COLON . instruction

    IDENTIFICATEUR  décalage et aller à l'état 44
    FOR             décalage et aller à l'état 45
    WHILE           décalage et aller à l'état 46
    IF              décalage et aller à l'état 47
    SWITCH          décalage et aller à l'état 48
    BREAK           décalage et aller à l'état 49
    RETURN          décalage et aller à l'état 50

    $défaut  réduction par utilisation de la règle 29 ($@3)

    instruction  aller à l'état 156
    $@3          aller à l'état 54
    iteration    aller à l'état 55
    selection    aller à l'état 56
    appel        aller à l'état 57
    saut         aller à l'état 58
    affectation  aller à l'état 59
    variable     aller à l'état 60
    var          aller à l'état 61


état 154

   31 iteration: FOR LPAREN affectation SEMICOLON condition SEMICOLON affectation RPAREN instruction .

    $défaut  réduction par utilisation de la règle 31 (iteration)


état 155

   38 cases: cases CASE CONSTANTE COLON . instruction

    IDENTIFICATEUR  décalage et aller à l'état 44
    FOR             décalage et aller à l'état 45
    WHILE           décalage et aller à l'état 46
    IF              décalage et aller à l'état 47
    SWITCH          décalage et aller à l'état 48
    BREAK           décalage et aller à l'état 49
    RETURN          décalage et aller à l'état 50

    $défaut  réduction par utilisation de la règle 29 ($@3)

    instruction  aller à l'état 157
    $@3          aller à l'état 54
    iteration    aller à l'état 55
    selection    aller à l'état 56
    appel        aller à l'état 57
    saut         aller à l'état 58
    affectation  aller à l'état 59
    variable     aller à l'état 60
    var          aller à l'état 61


état 156

   40 default_case: DEFAULT COLON instruction .

    $défaut  réduction par utilisation de la règle 40 (default_case)


état 157

   38 cases: cases CASE CONSTANTE COLON instruction .

    $défaut  réduction par utilisation de la règle 38 (cases)
