Grammaire

    0 $accept: programme $end

    1 programme: liste_declarations liste_fonctions

    2 liste_declarations: liste_declarations declaration
    3                   | declaration_fonction

    4 declaration_fonction: /* vide */
    5                     | declaration_fonction EXTERN type IDENTIFICATEUR LPAREN liste_parms RPAREN SEMICOLON

    6 liste_fonctions: liste_fonctions fonction
    7                | fonction

    8 declaration: type liste_declarateurs SEMICOLON

    9 liste_declarateurs: liste_declarateurs COMMA declarateur
   10                   | declarateur

   11 declarateur: IDENTIFICATEUR
   12            | declarateur LBRACKET CONSTANTE RBRACKET

   13 $@1: /* vide */

   14 $@2: /* vide */

   15 fonction: type IDENTIFICATEUR LPAREN liste_parms RPAREN $@1 bloc $@2

   16 type: VOID
   17     | INT

   18 liste_parms: liste_parms COMMA parm
   19            | parm
   20            | /* vide */

   21 parm: INT IDENTIFICATEUR

   22 liste_instructions: instruction liste_instructions
   23                   | /* vide */

   24 instruction: iteration
   25            | selection
   26            | saut
   27            | appel
   28            | affectation SEMICOLON

   29 $@3: /* vide */

   30 instruction: $@3 bloc

   31 iteration: FOR LPAREN affectation SEMICOLON condition SEMICOLON affectation RPAREN instruction
   32          | WHILE LPAREN condition RPAREN instruction

   33 selection: IF LPAREN condition RPAREN instruction
   34          | IF LPAREN condition RPAREN instruction ELSE instruction
   35          | SWITCH LPAREN expression RPAREN LBRACE switch_block RBRACE

   36 switch_block: /* vide */
   37             | cases
   38             | DEFAULT COLON instruction

   39 cases: CASE CONSTANTE COLON instruction cases
   40      | CASE CONSTANTE COLON instruction

   41 appel: IDENTIFICATEUR LPAREN liste_expressions RPAREN SEMICOLON

   42 saut: BREAK SEMICOLON
   43     | RETURN SEMICOLON
   44     | RETURN expression SEMICOLON

   45 bloc: LBRACE liste_declarations liste_instructions RBRACE

   46 affectation: variable OP expression

   47 variable: IDENTIFICATEUR
   48         | variable LBRACKET expression RBRACKET

   49 expression: LPAREN expression RPAREN
   50           | expression binary_op expression
   51           | MOINS expression
   52           | CONSTANTE
   53           | variable
   54           | IDENTIFICATEUR LPAREN liste_expressions RPAREN

   55 liste_expressions: liste_expressions COMMA expression
   56                  | expression
   57                  | /* vide */

   58 condition: NOT LPAREN condition RPAREN
   59          | condition binary_rel condition
   60          | LPAREN condition RPAREN
   61          | expression binary_comp expression

   62 binary_op: PLUS
   63          | MOINS
   64          | MUL
   65          | DIV
   66          | LSHIFT
   67          | RSHIFT
   68          | BAND
   69          | BOR

   70 binary_rel: LAND
   71           | LOR

   72 binary_comp: LT
   73            | GT
   74            | GEQ
   75            | LEQ
   76            | EQ
   77            | NEQ


Terminaux, suivis des règles où ils apparaissent

$end (0) 0
error (256)
IDENTIFICATEUR (258) 5 11 15 21 41 47 54
CONSTANTE (259) 12 39 40 52
VOID (260) 16
INT (261) 17 21
FOR (262) 31
WHILE (263) 32
IF (264) 33 34
ELSE (265) 34
SWITCH (266) 35
CASE (267) 39 40
DEFAULT (268) 38
BREAK (269) 42
RETURN (270) 43 44
PLUS (271) 62
MOINS (272) 51 63
MUL (273) 64
DIV (274) 65
LSHIFT (275) 66
RSHIFT (276) 67
BAND (277) 68
BOR (278) 69
LAND (279) 70
LOR (280) 71
LT (281) 72
GT (282) 73
GEQ (283) 74
LEQ (284) 75
EQ (285) 76
NEQ (286) 77
NOT (287) 58
EXTERN (288) 5
LBRACE (289) 35 45
RBRACE (290) 35 45
LPAREN (291) 5 15 31 32 33 34 35 41 49 54 58 60
RPAREN (292) 5 15 31 32 33 34 35 41 49 54 58 60
COMMA (293) 9 18 55
LBRACKET (294) 12 48
RBRACKET (295) 12 48
SEMICOLON (296) 5 8 28 31 41 42 43 44
COLON (297) 38 39 40
THEN (298)
OP (299) 46
REL (300)


Non-terminaux, suivis des règles où ils apparaissent

$accept (46)
    à gauche: 0
programme (47)
    à gauche: 1, à droite: 0
liste_declarations (48)
    à gauche: 2 3, à droite: 1 2 45
declaration_fonction (49)
    à gauche: 4 5, à droite: 3 5
liste_fonctions (50)
    à gauche: 6 7, à droite: 1 6
declaration (51)
    à gauche: 8, à droite: 2
liste_declarateurs (52)
    à gauche: 9 10, à droite: 8 9
declarateur (53)
    à gauche: 11 12, à droite: 9 10 12
fonction (54)
    à gauche: 15, à droite: 6 7
$@1 (55)
    à gauche: 13, à droite: 15
$@2 (56)
    à gauche: 14, à droite: 15
type (57)
    à gauche: 16 17, à droite: 5 8 15
liste_parms (58)
    à gauche: 18 19 20, à droite: 5 15 18
parm (59)
    à gauche: 21, à droite: 18 19
liste_instructions (60)
    à gauche: 22 23, à droite: 22 45
instruction (61)
    à gauche: 24 25 26 27 28 30, à droite: 22 31 32 33 34 38 39 40
$@3 (62)
    à gauche: 29, à droite: 30
iteration (63)
    à gauche: 31 32, à droite: 24
selection (64)
    à gauche: 33 34 35, à droite: 25
switch_block (65)
    à gauche: 36 37 38, à droite: 35
cases (66)
    à gauche: 39 40, à droite: 37 39
appel (67)
    à gauche: 41, à droite: 27
saut (68)
    à gauche: 42 43 44, à droite: 26
bloc (69)
    à gauche: 45, à droite: 15 30
affectation (70)
    à gauche: 46, à droite: 28 31
variable (71)
    à gauche: 47 48, à droite: 46 48 53
expression (72)
    à gauche: 49 50 51 52 53 54, à droite: 35 44 46 48 49 50 51 55
    56 61
liste_expressions (73)
    à gauche: 55 56 57, à droite: 41 54 55
condition (74)
    à gauche: 58 59 60 61, à droite: 31 32 33 34 58 59 60
binary_op (75)
    à gauche: 62 63 64 65 66 67 68 69, à droite: 50
binary_rel (76)
    à gauche: 70 71, à droite: 59
binary_comp (77)
    à gauche: 72 73 74 75 76 77, à droite: 61


état 0

    0 $accept: . programme $end

    $défaut  réduction par utilisation de la règle 4 (declaration_fonction)

    programme             aller à l'état 1
    liste_declarations    aller à l'état 2
    declaration_fonction  aller à l'état 3


état 1

    0 $accept: programme . $end

    $end  décalage et aller à l'état 4


état 2

    1 programme: liste_declarations . liste_fonctions
    2 liste_declarations: liste_declarations . declaration

    VOID  décalage et aller à l'état 5
    INT   décalage et aller à l'état 6

    liste_fonctions  aller à l'état 7
    declaration      aller à l'état 8
    fonction         aller à l'état 9
    type             aller à l'état 10


état 3

    3 liste_declarations: declaration_fonction .
    5 declaration_fonction: declaration_fonction . EXTERN type IDENTIFICATEUR LPAREN liste_parms RPAREN SEMICOLON

    EXTERN  décalage et aller à l'état 11

    $défaut  réduction par utilisation de la règle 3 (liste_declarations)


état 4

    0 $accept: programme $end .

    $défaut  accepter


état 5

   16 type: VOID .

    $défaut  réduction par utilisation de la règle 16 (type)


état 6

   17 type: INT .

    $défaut  réduction par utilisation de la règle 17 (type)


état 7

    1 programme: liste_declarations liste_fonctions .
    6 liste_fonctions: liste_fonctions . fonction

    VOID  décalage et aller à l'état 5
    INT   décalage et aller à l'état 6

    $défaut  réduction par utilisation de la règle 1 (programme)

    fonction  aller à l'état 12
    type      aller à l'état 13


état 8

    2 liste_declarations: liste_declarations declaration .

    $défaut  réduction par utilisation de la règle 2 (liste_declarations)


état 9

    7 liste_fonctions: fonction .

    $défaut  réduction par utilisation de la règle 7 (liste_fonctions)


état 10

    8 declaration: type . liste_declarateurs SEMICOLON
   15 fonction: type . IDENTIFICATEUR LPAREN liste_parms RPAREN $@1 bloc $@2

    IDENTIFICATEUR  décalage et aller à l'état 14

    liste_declarateurs  aller à l'état 15
    declarateur         aller à l'état 16


état 11

    5 declaration_fonction: declaration_fonction EXTERN . type IDENTIFICATEUR LPAREN liste_parms RPAREN SEMICOLON

    VOID  décalage et aller à l'état 5
    INT   décalage et aller à l'état 6

    type  aller à l'état 17


état 12

    6 liste_fonctions: liste_fonctions fonction .

    $défaut  réduction par utilisation de la règle 6 (liste_fonctions)


état 13

   15 fonction: type . IDENTIFICATEUR LPAREN liste_parms RPAREN $@1 bloc $@2

    IDENTIFICATEUR  décalage et aller à l'état 18


état 14

   11 declarateur: IDENTIFICATEUR .
   15 fonction: type IDENTIFICATEUR . LPAREN liste_parms RPAREN $@1 bloc $@2

    LPAREN  décalage et aller à l'état 19

    $défaut  réduction par utilisation de la règle 11 (declarateur)


état 15

    8 declaration: type liste_declarateurs . SEMICOLON
    9 liste_declarateurs: liste_declarateurs . COMMA declarateur

    COMMA      décalage et aller à l'état 20
    SEMICOLON  décalage et aller à l'état 21


état 16

   10 liste_declarateurs: declarateur .
   12 declarateur: declarateur . LBRACKET CONSTANTE RBRACKET

    LBRACKET  décalage et aller à l'état 22

    $défaut  réduction par utilisation de la règle 10 (liste_declarateurs)


état 17

    5 declaration_fonction: declaration_fonction EXTERN type . IDENTIFICATEUR LPAREN liste_parms RPAREN SEMICOLON

    IDENTIFICATEUR  décalage et aller à l'état 23


état 18

   15 fonction: type IDENTIFICATEUR . LPAREN liste_parms RPAREN $@1 bloc $@2

    LPAREN  décalage et aller à l'état 19


état 19

   15 fonction: type IDENTIFICATEUR LPAREN . liste_parms RPAREN $@1 bloc $@2

    INT  décalage et aller à l'état 24

    $défaut  réduction par utilisation de la règle 20 (liste_parms)

    liste_parms  aller à l'état 25
    parm         aller à l'état 26


état 20

    9 liste_declarateurs: liste_declarateurs COMMA . declarateur

    IDENTIFICATEUR  décalage et aller à l'état 27

    declarateur  aller à l'état 28


état 21

    8 declaration: type liste_declarateurs SEMICOLON .

    $défaut  réduction par utilisation de la règle 8 (declaration)


état 22

   12 declarateur: declarateur LBRACKET . CONSTANTE RBRACKET

    CONSTANTE  décalage et aller à l'état 29


état 23

    5 declaration_fonction: declaration_fonction EXTERN type IDENTIFICATEUR . LPAREN liste_parms RPAREN SEMICOLON

    LPAREN  décalage et aller à l'état 30


état 24

   21 parm: INT . IDENTIFICATEUR

    IDENTIFICATEUR  décalage et aller à l'état 31


état 25

   15 fonction: type IDENTIFICATEUR LPAREN liste_parms . RPAREN $@1 bloc $@2
   18 liste_parms: liste_parms . COMMA parm

    RPAREN  décalage et aller à l'état 32
    COMMA   décalage et aller à l'état 33


état 26

   19 liste_parms: parm .

    $défaut  réduction par utilisation de la règle 19 (liste_parms)


état 27

   11 declarateur: IDENTIFICATEUR .

    $défaut  réduction par utilisation de la règle 11 (declarateur)


état 28

    9 liste_declarateurs: liste_declarateurs COMMA declarateur .
   12 declarateur: declarateur . LBRACKET CONSTANTE RBRACKET

    LBRACKET  décalage et aller à l'état 22

    $défaut  réduction par utilisation de la règle 9 (liste_declarateurs)


état 29

   12 declarateur: declarateur LBRACKET CONSTANTE . RBRACKET

    RBRACKET  décalage et aller à l'état 34


état 30

    5 declaration_fonction: declaration_fonction EXTERN type IDENTIFICATEUR LPAREN . liste_parms RPAREN SEMICOLON

    INT  décalage et aller à l'état 24

    $défaut  réduction par utilisation de la règle 20 (liste_parms)

    liste_parms  aller à l'état 35
    parm         aller à l'état 26


état 31

   21 parm: INT IDENTIFICATEUR .

    $défaut  réduction par utilisation de la règle 21 (parm)


état 32

   15 fonction: type IDENTIFICATEUR LPAREN liste_parms RPAREN . $@1 bloc $@2

    $défaut  réduction par utilisation de la règle 13 ($@1)

    $@1  aller à l'état 36


état 33

   18 liste_parms: liste_parms COMMA . parm

    INT  décalage et aller à l'état 24

    parm  aller à l'état 37


état 34

   12 declarateur: declarateur LBRACKET CONSTANTE RBRACKET .

    $défaut  réduction par utilisation de la règle 12 (declarateur)


état 35

    5 declaration_fonction: declaration_fonction EXTERN type IDENTIFICATEUR LPAREN liste_parms . RPAREN SEMICOLON
   18 liste_parms: liste_parms . COMMA parm

    RPAREN  décalage et aller à l'état 38
    COMMA   décalage et aller à l'état 33


état 36

   15 fonction: type IDENTIFICATEUR LPAREN liste_parms RPAREN $@1 . bloc $@2

    LBRACE  décalage et aller à l'état 39

    bloc  aller à l'état 40


état 37

   18 liste_parms: liste_parms COMMA parm .

    $défaut  réduction par utilisation de la règle 18 (liste_parms)


état 38

    5 declaration_fonction: declaration_fonction EXTERN type IDENTIFICATEUR LPAREN liste_parms RPAREN . SEMICOLON

    SEMICOLON  décalage et aller à l'état 41


état 39

   45 bloc: LBRACE . liste_declarations liste_instructions RBRACE

    $défaut  réduction par utilisation de la règle 4 (declaration_fonction)

    liste_declarations    aller à l'état 42
    declaration_fonction  aller à l'état 3


état 40

   15 fonction: type IDENTIFICATEUR LPAREN liste_parms RPAREN $@1 bloc . $@2

    $défaut  réduction par utilisation de la règle 14 ($@2)

    $@2  aller à l'état 43


état 41

    5 declaration_fonction: declaration_fonction EXTERN type IDENTIFICATEUR LPAREN liste_parms RPAREN SEMICOLON .

    $défaut  réduction par utilisation de la règle 5 (declaration_fonction)


état 42

    2 liste_declarations: liste_declarations . declaration
   45 bloc: LBRACE liste_declarations . liste_instructions RBRACE

    IDENTIFICATEUR  décalage et aller à l'état 44
    VOID            décalage et aller à l'état 5
    INT             décalage et aller à l'état 6
    FOR             décalage et aller à l'état 45
    WHILE           décalage et aller à l'état 46
    IF              décalage et aller à l'état 47
    SWITCH          décalage et aller à l'état 48
    BREAK           décalage et aller à l'état 49
    RETURN          décalage et aller à l'état 50

    LBRACE   réduction par utilisation de la règle 29 ($@3)
    $défaut  réduction par utilisation de la règle 23 (liste_instructions)

    declaration         aller à l'état 8
    type                aller à l'état 51
    liste_instructions  aller à l'état 52
    instruction         aller à l'état 53
    $@3                 aller à l'état 54
    iteration           aller à l'état 55
    selection           aller à l'état 56
    appel               aller à l'état 57
    saut                aller à l'état 58
    affectation         aller à l'état 59
    variable            aller à l'état 60


état 43

   15 fonction: type IDENTIFICATEUR LPAREN liste_parms RPAREN $@1 bloc $@2 .

    $défaut  réduction par utilisation de la règle 15 (fonction)


état 44

   41 appel: IDENTIFICATEUR . LPAREN liste_expressions RPAREN SEMICOLON
   47 variable: IDENTIFICATEUR .

    LPAREN  décalage et aller à l'état 61

    $défaut  réduction par utilisation de la règle 47 (variable)


état 45

   31 iteration: FOR . LPAREN affectation SEMICOLON condition SEMICOLON affectation RPAREN instruction

    LPAREN  décalage et aller à l'état 62


état 46

   32 iteration: WHILE . LPAREN condition RPAREN instruction

    LPAREN  décalage et aller à l'état 63


état 47

   33 selection: IF . LPAREN condition RPAREN instruction
   34          | IF . LPAREN condition RPAREN instruction ELSE instruction

    LPAREN  décalage et aller à l'état 64


état 48

   35 selection: SWITCH . LPAREN expression RPAREN LBRACE switch_block RBRACE

    LPAREN  décalage et aller à l'état 65


état 49

   42 saut: BREAK . SEMICOLON

    SEMICOLON  décalage et aller à l'état 66


état 50

   43 saut: RETURN . SEMICOLON
   44     | RETURN . expression SEMICOLON

    IDENTIFICATEUR  décalage et aller à l'état 67
    CONSTANTE       décalage et aller à l'état 68
    MOINS           décalage et aller à l'état 69
    LPAREN          décalage et aller à l'état 70
    SEMICOLON       décalage et aller à l'état 71

    variable    aller à l'état 72
    expression  aller à l'état 73


état 51

    8 declaration: type . liste_declarateurs SEMICOLON

    IDENTIFICATEUR  décalage et aller à l'état 27

    liste_declarateurs  aller à l'état 15
    declarateur         aller à l'état 16


état 52

   45 bloc: LBRACE liste_declarations liste_instructions . RBRACE

    RBRACE  décalage et aller à l'état 74


état 53

   22 liste_instructions: instruction . liste_instructions

    IDENTIFICATEUR  décalage et aller à l'état 44
    FOR             décalage et aller à l'état 45
    WHILE           décalage et aller à l'état 46
    IF              décalage et aller à l'état 47
    SWITCH          décalage et aller à l'état 48
    BREAK           décalage et aller à l'état 49
    RETURN          décalage et aller à l'état 50

    LBRACE   réduction par utilisation de la règle 29 ($@3)
    $défaut  réduction par utilisation de la règle 23 (liste_instructions)

    liste_instructions  aller à l'état 75
    instruction         aller à l'état 53
    $@3                 aller à l'état 54
    iteration           aller à l'état 55
    selection           aller à l'état 56
    appel               aller à l'état 57
    saut                aller à l'état 58
    affectation         aller à l'état 59
    variable            aller à l'état 60


état 54

   30 instruction: $@3 . bloc

    LBRACE  décalage et aller à l'état 39

    bloc  aller à l'état 76


état 55

   24 instruction: iteration .

    $défaut  réduction par utilisation de la règle 24 (instruction)


état 56

   25 instruction: selection .

    $défaut  réduction par utilisation de la règle 25 (instruction)


état 57

   27 instruction: appel .

    $défaut  réduction par utilisation de la règle 27 (instruction)


état 58

   26 instruction: saut .

    $défaut  réduction par utilisation de la règle 26 (instruction)


état 59

   28 instruction: affectation . SEMICOLON

    SEMICOLON  décalage et aller à l'état 77


état 60

   46 affectation: variable . OP expression
   48 variable: variable . LBRACKET expression RBRACKET

    LBRACKET  décalage et aller à l'état 78
    OP        décalage et aller à l'état 79


état 61

   41 appel: IDENTIFICATEUR LPAREN . liste_expressions RPAREN SEMICOLON

    IDENTIFICATEUR  décalage et aller à l'état 67
    CONSTANTE       décalage et aller à l'état 68
    MOINS           décalage et aller à l'état 69
    LPAREN          décalage et aller à l'état 70

    $défaut  réduction par utilisation de la règle 57 (liste_expressions)

    variable           aller à l'état 72
    expression         aller à l'état 80
    liste_expressions  aller à l'état 81


état 62

   31 iteration: FOR LPAREN . affectation SEMICOLON condition SEMICOLON affectation RPAREN instruction

    IDENTIFICATEUR  décalage et aller à l'état 82

    affectation  aller à l'état 83
    variable     aller à l'état 60


état 63

   32 iteration: WHILE LPAREN . condition RPAREN instruction

    IDENTIFICATEUR  décalage et aller à l'état 67
    CONSTANTE       décalage et aller à l'état 68
    MOINS           décalage et aller à l'état 69
    NOT             décalage et aller à l'état 84
    LPAREN          décalage et aller à l'état 85

    variable    aller à l'état 72
    expression  aller à l'état 86
    condition   aller à l'état 87


état 64

   33 selection: IF LPAREN . condition RPAREN instruction
   34          | IF LPAREN . condition RPAREN instruction ELSE instruction

    IDENTIFICATEUR  décalage et aller à l'état 67
    CONSTANTE       décalage et aller à l'état 68
    MOINS           décalage et aller à l'état 69
    NOT             décalage et aller à l'état 84
    LPAREN          décalage et aller à l'état 85

    variable    aller à l'état 72
    expression  aller à l'état 86
    condition   aller à l'état 88


état 65

   35 selection: SWITCH LPAREN . expression RPAREN LBRACE switch_block RBRACE

    IDENTIFICATEUR  décalage et aller à l'état 67
    CONSTANTE       décalage et aller à l'état 68
    MOINS           décalage et aller à l'état 69
    LPAREN          décalage et aller à l'état 70

    variable    aller à l'état 72
    expression  aller à l'état 89


état 66

   42 saut: BREAK SEMICOLON .

    $défaut  réduction par utilisation de la règle 42 (saut)


état 67

   47 variable: IDENTIFICATEUR .
   54 expression: IDENTIFICATEUR . LPAREN liste_expressions RPAREN

    LPAREN  décalage et aller à l'état 90

    $défaut  réduction par utilisation de la règle 47 (variable)


état 68

   52 expression: CONSTANTE .

    $défaut  réduction par utilisation de la règle 52 (expression)


état 69

   51 expression: MOINS . expression

    IDENTIFICATEUR  décalage et aller à l'état 67
    CONSTANTE       décalage et aller à l'état 68
    MOINS           décalage et aller à l'état 69
    LPAREN          décalage et aller à l'état 70

    variable    aller à l'état 72
    expression  aller à l'état 91


état 70

   49 expression: LPAREN . expression RPAREN

    IDENTIFICATEUR  décalage et aller à l'état 67
    CONSTANTE       décalage et aller à l'état 68
    MOINS           décalage et aller à l'état 69
    LPAREN          décalage et aller à l'état 70

    variable    aller à l'état 72
    expression  aller à l'état 92


état 71

   43 saut: RETURN SEMICOLON .

    $défaut  réduction par utilisation de la règle 43 (saut)


état 72

   48 variable: variable . LBRACKET expression RBRACKET
   53 expression: variable .

    LBRACKET  décalage et aller à l'état 78

    $défaut  réduction par utilisation de la règle 53 (expression)


état 73

   44 saut: RETURN expression . SEMICOLON
   50 expression: expression . binary_op expression

    PLUS       décalage et aller à l'état 93
    MOINS      décalage et aller à l'état 94
    MUL        décalage et aller à l'état 95
    DIV        décalage et aller à l'état 96
    LSHIFT     décalage et aller à l'état 97
    RSHIFT     décalage et aller à l'état 98
    BAND       décalage et aller à l'état 99
    BOR        décalage et aller à l'état 100
    SEMICOLON  décalage et aller à l'état 101

    binary_op  aller à l'état 102


état 74

   45 bloc: LBRACE liste_declarations liste_instructions RBRACE .

    $défaut  réduction par utilisation de la règle 45 (bloc)


état 75

   22 liste_instructions: instruction liste_instructions .

    $défaut  réduction par utilisation de la règle 22 (liste_instructions)


état 76

   30 instruction: $@3 bloc .

    $défaut  réduction par utilisation de la règle 30 (instruction)


état 77

   28 instruction: affectation SEMICOLON .

    $défaut  réduction par utilisation de la règle 28 (instruction)


état 78

   48 variable: variable LBRACKET . expression RBRACKET

    IDENTIFICATEUR  décalage et aller à l'état 67
    CONSTANTE       décalage et aller à l'état 68
    MOINS           décalage et aller à l'état 69
    LPAREN          décalage et aller à l'état 70

    variable    aller à l'état 72
    expression  aller à l'état 103


état 79

   46 affectation: variable OP . expression

    IDENTIFICATEUR  décalage et aller à l'état 67
    CONSTANTE       décalage et aller à l'état 68
    MOINS           décalage et aller à l'état 69
    LPAREN          décalage et aller à l'état 70

    variable    aller à l'état 72
    expression  aller à l'état 104


état 80

   50 expression: expression . binary_op expression
   56 liste_expressions: expression .

    PLUS    décalage et aller à l'état 93
    MOINS   décalage et aller à l'état 94
    MUL     décalage et aller à l'état 95
    DIV     décalage et aller à l'état 96
    LSHIFT  décalage et aller à l'état 97
    RSHIFT  décalage et aller à l'état 98
    BAND    décalage et aller à l'état 99
    BOR     décalage et aller à l'état 100

    $défaut  réduction par utilisation de la règle 56 (liste_expressions)

    binary_op  aller à l'état 102


état 81

   41 appel: IDENTIFICATEUR LPAREN liste_expressions . RPAREN SEMICOLON
   55 liste_expressions: liste_expressions . COMMA expression

    RPAREN  décalage et aller à l'état 105
    COMMA   décalage et aller à l'état 106


état 82

   47 variable: IDENTIFICATEUR .

    $défaut  réduction par utilisation de la règle 47 (variable)


état 83

   31 iteration: FOR LPAREN affectation . SEMICOLON condition SEMICOLON affectation RPAREN instruction

    SEMICOLON  décalage et aller à l'état 107


état 84

   58 condition: NOT . LPAREN condition RPAREN

    LPAREN  décalage et aller à l'état 108


état 85

   49 expression: LPAREN . expression RPAREN
   60 condition: LPAREN . condition RPAREN

    IDENTIFICATEUR  décalage et aller à l'état 67
    CONSTANTE       décalage et aller à l'état 68
    MOINS           décalage et aller à l'état 69
    NOT             décalage et aller à l'état 84
    LPAREN          décalage et aller à l'état 85

    variable    aller à l'état 72
    expression  aller à l'état 109
    condition   aller à l'état 110


état 86

   50 expression: expression . binary_op expression
   61 condition: expression . binary_comp expression

    PLUS    décalage et aller à l'état 93
    MOINS   décalage et aller à l'état 94
    MUL     décalage et aller à l'état 95
    DIV     décalage et aller à l'état 96
    LSHIFT  décalage et aller à l'état 97
    RSHIFT  décalage et aller à l'état 98
    BAND    décalage et aller à l'état 99
    BOR     décalage et aller à l'état 100
    LT      décalage et aller à l'état 111
    GT      décalage et aller à l'état 112
    GEQ     décalage et aller à l'état 113
    LEQ     décalage et aller à l'état 114
    EQ      décalage et aller à l'état 115
    NEQ     décalage et aller à l'état 116

    binary_op    aller à l'état 102
    binary_comp  aller à l'état 117


état 87

   32 iteration: WHILE LPAREN condition . RPAREN instruction
   59 condition: condition . binary_rel condition

    LAND    décalage et aller à l'état 118
    LOR     décalage et aller à l'état 119
    RPAREN  décalage et aller à l'état 120

    binary_rel  aller à l'état 121


état 88

   33 selection: IF LPAREN condition . RPAREN instruction
   34          | IF LPAREN condition . RPAREN instruction ELSE instruction
   59 condition: condition . binary_rel condition

    LAND    décalage et aller à l'état 118
    LOR     décalage et aller à l'état 119
    RPAREN  décalage et aller à l'état 122

    binary_rel  aller à l'état 121


état 89

   35 selection: SWITCH LPAREN expression . RPAREN LBRACE switch_block RBRACE
   50 expression: expression . binary_op expression

    PLUS    décalage et aller à l'état 93
    MOINS   décalage et aller à l'état 94
    MUL     décalage et aller à l'état 95
    DIV     décalage et aller à l'état 96
    LSHIFT  décalage et aller à l'état 97
    RSHIFT  décalage et aller à l'état 98
    BAND    décalage et aller à l'état 99
    BOR     décalage et aller à l'état 100
    RPAREN  décalage et aller à l'état 123

    binary_op  aller à l'état 102


état 90

   54 expression: IDENTIFICATEUR LPAREN . liste_expressions RPAREN

    IDENTIFICATEUR  décalage et aller à l'état 67
    CONSTANTE       décalage et aller à l'état 68
    MOINS           décalage et aller à l'état 69
    LPAREN          décalage et aller à l'état 70

    $défaut  réduction par utilisation de la règle 57 (liste_expressions)

    variable           aller à l'état 72
    expression         aller à l'état 80
    liste_expressions  aller à l'état 124


état 91

   50 expression: expression . binary_op expression
   51           | MOINS expression .

    MUL     décalage et aller à l'état 95
    DIV     décalage et aller à l'état 96
    LSHIFT  décalage et aller à l'état 97
    RSHIFT  décalage et aller à l'état 98
    BAND    décalage et aller à l'état 99
    BOR     décalage et aller à l'état 100

    $défaut  réduction par utilisation de la règle 51 (expression)

    binary_op  aller à l'état 102


état 92

   49 expression: LPAREN expression . RPAREN
   50           | expression . binary_op expression

    PLUS    décalage et aller à l'état 93
    MOINS   décalage et aller à l'état 94
    MUL     décalage et aller à l'état 95
    DIV     décalage et aller à l'état 96
    LSHIFT  décalage et aller à l'état 97
    RSHIFT  décalage et aller à l'état 98
    BAND    décalage et aller à l'état 99
    BOR     décalage et aller à l'état 100
    RPAREN  décalage et aller à l'état 125

    binary_op  aller à l'état 102


état 93

   62 binary_op: PLUS .

    $défaut  réduction par utilisation de la règle 62 (binary_op)


état 94

   63 binary_op: MOINS .

    $défaut  réduction par utilisation de la règle 63 (binary_op)


état 95

   64 binary_op: MUL .

    $défaut  réduction par utilisation de la règle 64 (binary_op)


état 96

   65 binary_op: DIV .

    $défaut  réduction par utilisation de la règle 65 (binary_op)


état 97

   66 binary_op: LSHIFT .

    $défaut  réduction par utilisation de la règle 66 (binary_op)


état 98

   67 binary_op: RSHIFT .

    $défaut  réduction par utilisation de la règle 67 (binary_op)


état 99

   68 binary_op: BAND .

    $défaut  réduction par utilisation de la règle 68 (binary_op)


état 100

   69 binary_op: BOR .

    $défaut  réduction par utilisation de la règle 69 (binary_op)


état 101

   44 saut: RETURN expression SEMICOLON .

    $défaut  réduction par utilisation de la règle 44 (saut)


état 102

   50 expression: expression binary_op . expression

    IDENTIFICATEUR  décalage et aller à l'état 67
    CONSTANTE       décalage et aller à l'état 68
    MOINS           décalage et aller à l'état 69
    LPAREN          décalage et aller à l'état 70

    variable    aller à l'état 72
    expression  aller à l'état 126


état 103

   48 variable: variable LBRACKET expression . RBRACKET
   50 expression: expression . binary_op expression

    PLUS      décalage et aller à l'état 93
    MOINS     décalage et aller à l'état 94
    MUL       décalage et aller à l'état 95
    DIV       décalage et aller à l'état 96
    LSHIFT    décalage et aller à l'état 97
    RSHIFT    décalage et aller à l'état 98
    BAND      décalage et aller à l'état 99
    BOR       décalage et aller à l'état 100
    RBRACKET  décalage et aller à l'état 127

    binary_op  aller à l'état 102


état 104

   46 affectation: variable OP expression .
   50 expression: expression . binary_op expression

    PLUS    décalage et aller à l'état 93
    MOINS   décalage et aller à l'état 94
    MUL     décalage et aller à l'état 95
    DIV     décalage et aller à l'état 96
    LSHIFT  décalage et aller à l'état 97
    RSHIFT  décalage et aller à l'état 98
    BAND    décalage et aller à l'état 99
    BOR     décalage et aller à l'état 100

    $défaut  réduction par utilisation de la règle 46 (affectation)

    binary_op  aller à l'état 102


état 105

   41 appel: IDENTIFICATEUR LPAREN liste_expressions RPAREN . SEMICOLON

    SEMICOLON  décalage et aller à l'état 128


état 106

   55 liste_expressions: liste_expressions COMMA . expression

    IDENTIFICATEUR  décalage et aller à l'état 67
    CONSTANTE       décalage et aller à l'état 68
    MOINS           décalage et aller à l'état 69
    LPAREN          décalage et aller à l'état 70

    variable    aller à l'état 72
    expression  aller à l'état 129


état 107

   31 iteration: FOR LPAREN affectation SEMICOLON . condition SEMICOLON affectation RPAREN instruction

    IDENTIFICATEUR  décalage et aller à l'état 67
    CONSTANTE       décalage et aller à l'état 68
    MOINS           décalage et aller à l'état 69
    NOT             décalage et aller à l'état 84
    LPAREN          décalage et aller à l'état 85

    variable    aller à l'état 72
    expression  aller à l'état 86
    condition   aller à l'état 130


état 108

   58 condition: NOT LPAREN . condition RPAREN

    IDENTIFICATEUR  décalage et aller à l'état 67
    CONSTANTE       décalage et aller à l'état 68
    MOINS           décalage et aller à l'état 69
    NOT             décalage et aller à l'état 84
    LPAREN          décalage et aller à l'état 85

    variable    aller à l'état 72
    expression  aller à l'état 86
    condition   aller à l'état 131


état 109

   49 expression: LPAREN expression . RPAREN
   50           | expression . binary_op expression
   61 condition: expression . binary_comp expression

    PLUS    décalage et aller à l'état 93
    MOINS   décalage et aller à l'état 94
    MUL     décalage et aller à l'état 95
    DIV     décalage et aller à l'état 96
    LSHIFT  décalage et aller à l'état 97
    RSHIFT  décalage et aller à l'état 98
    BAND    décalage et aller à l'état 99
    BOR     décalage et aller à l'état 100
    LT      décalage et aller à l'état 111
    GT      décalage et aller à l'état 112
    GEQ     décalage et aller à l'état 113
    LEQ     décalage et aller à l'état 114
    EQ      décalage et aller à l'état 115
    NEQ     décalage et aller à l'état 116
    RPAREN  décalage et aller à l'état 125

    binary_op    aller à l'état 102
    binary_comp  aller à l'état 117


état 110

   59 condition: condition . binary_rel condition
   60          | LPAREN condition . RPAREN

    LAND    décalage et aller à l'état 118
    LOR     décalage et aller à l'état 119
    RPAREN  décalage et aller à l'état 132

    binary_rel  aller à l'état 121


état 111

   72 binary_comp: LT .

    $défaut  réduction par utilisation de la règle 72 (binary_comp)


état 112

   73 binary_comp: GT .

    $défaut  réduction par utilisation de la règle 73 (binary_comp)


état 113

   74 binary_comp: GEQ .

    $défaut  réduction par utilisation de la règle 74 (binary_comp)


état 114

   75 binary_comp: LEQ .

    $défaut  réduction par utilisation de la règle 75 (binary_comp)


état 115

   76 binary_comp: EQ .

    $défaut  réduction par utilisation de la règle 76 (binary_comp)


état 116

   77 binary_comp: NEQ .

    $défaut  réduction par utilisation de la règle 77 (binary_comp)


état 117

   61 condition: expression binary_comp . expression

    IDENTIFICATEUR  décalage et aller à l'état 67
    CONSTANTE       décalage et aller à l'état 68
    MOINS           décalage et aller à l'état 69
    LPAREN          décalage et aller à l'état 70

    variable    aller à l'état 72
    expression  aller à l'état 133


état 118

   70 binary_rel: LAND .

    $défaut  réduction par utilisation de la règle 70 (binary_rel)


état 119

   71 binary_rel: LOR .

    $défaut  réduction par utilisation de la règle 71 (binary_rel)


état 120

   32 iteration: WHILE LPAREN condition RPAREN . instruction

    IDENTIFICATEUR  décalage et aller à l'état 44
    FOR             décalage et aller à l'état 45
    WHILE           décalage et aller à l'état 46
    IF              décalage et aller à l'état 47
    SWITCH          décalage et aller à l'état 48
    BREAK           décalage et aller à l'état 49
    RETURN          décalage et aller à l'état 50

    $défaut  réduction par utilisation de la règle 29 ($@3)

    instruction  aller à l'état 134
    $@3          aller à l'état 54
    iteration    aller à l'état 55
    selection    aller à l'état 56
    appel        aller à l'état 57
    saut         aller à l'état 58
    affectation  aller à l'état 59
    variable     aller à l'état 60


état 121

   59 condition: condition binary_rel . condition

    IDENTIFICATEUR  décalage et aller à l'état 67
    CONSTANTE       décalage et aller à l'état 68
    MOINS           décalage et aller à l'état 69
    NOT             décalage et aller à l'état 84
    LPAREN          décalage et aller à l'état 85

    variable    aller à l'état 72
    expression  aller à l'état 86
    condition   aller à l'état 135


état 122

   33 selection: IF LPAREN condition RPAREN . instruction
   34          | IF LPAREN condition RPAREN . instruction ELSE instruction

    IDENTIFICATEUR  décalage et aller à l'état 44
    FOR             décalage et aller à l'état 45
    WHILE           décalage et aller à l'état 46
    IF              décalage et aller à l'état 47
    SWITCH          décalage et aller à l'état 48
    BREAK           décalage et aller à l'état 49
    RETURN          décalage et aller à l'état 50

    $défaut  réduction par utilisation de la règle 29 ($@3)

    instruction  aller à l'état 136
    $@3          aller à l'état 54
    iteration    aller à l'état 55
    selection    aller à l'état 56
    appel        aller à l'état 57
    saut         aller à l'état 58
    affectation  aller à l'état 59
    variable     aller à l'état 60


état 123

   35 selection: SWITCH LPAREN expression RPAREN . LBRACE switch_block RBRACE

    LBRACE  décalage et aller à l'état 137


état 124

   54 expression: IDENTIFICATEUR LPAREN liste_expressions . RPAREN
   55 liste_expressions: liste_expressions . COMMA expression

    RPAREN  décalage et aller à l'état 138
    COMMA   décalage et aller à l'état 106


état 125

   49 expression: LPAREN expression RPAREN .

    $défaut  réduction par utilisation de la règle 49 (expression)


état 126

   50 expression: expression . binary_op expression
   50           | expression binary_op expression .

    $défaut  réduction par utilisation de la règle 50 (expression)

    binary_op  aller à l'état 102


état 127

   48 variable: variable LBRACKET expression RBRACKET .

    $défaut  réduction par utilisation de la règle 48 (variable)


état 128

   41 appel: IDENTIFICATEUR LPAREN liste_expressions RPAREN SEMICOLON .

    $défaut  réduction par utilisation de la règle 41 (appel)


état 129

   50 expression: expression . binary_op expression
   55 liste_expressions: liste_expressions COMMA expression .

    PLUS    décalage et aller à l'état 93
    MOINS   décalage et aller à l'état 94
    MUL     décalage et aller à l'état 95
    DIV     décalage et aller à l'état 96
    LSHIFT  décalage et aller à l'état 97
    RSHIFT  décalage et aller à l'état 98
    BAND    décalage et aller à l'état 99
    BOR     décalage et aller à l'état 100

    $défaut  réduction par utilisation de la règle 55 (liste_expressions)

    binary_op  aller à l'état 102


état 130

   31 iteration: FOR LPAREN affectation SEMICOLON condition . SEMICOLON affectation RPAREN instruction
   59 condition: condition . binary_rel condition

    LAND       décalage et aller à l'état 118
    LOR        décalage et aller à l'état 119
    SEMICOLON  décalage et aller à l'état 139

    binary_rel  aller à l'état 121


état 131

   58 condition: NOT LPAREN condition . RPAREN
   59          | condition . binary_rel condition

    LAND    décalage et aller à l'état 118
    LOR     décalage et aller à l'état 119
    RPAREN  décalage et aller à l'état 140

    binary_rel  aller à l'état 121


état 132

   60 condition: LPAREN condition RPAREN .

    $défaut  réduction par utilisation de la règle 60 (condition)


état 133

   50 expression: expression . binary_op expression
   61 condition: expression binary_comp expression .

    PLUS    décalage et aller à l'état 93
    MOINS   décalage et aller à l'état 94
    MUL     décalage et aller à l'état 95
    DIV     décalage et aller à l'état 96
    LSHIFT  décalage et aller à l'état 97
    RSHIFT  décalage et aller à l'état 98
    BAND    décalage et aller à l'état 99
    BOR     décalage et aller à l'état 100

    $défaut  réduction par utilisation de la règle 61 (condition)

    binary_op  aller à l'état 102


état 134

   32 iteration: WHILE LPAREN condition RPAREN instruction .

    $défaut  réduction par utilisation de la règle 32 (iteration)


état 135

   59 condition: condition . binary_rel condition
   59          | condition binary_rel condition .

    $défaut  réduction par utilisation de la règle 59 (condition)

    binary_rel  aller à l'état 121


état 136

   33 selection: IF LPAREN condition RPAREN instruction .
   34          | IF LPAREN condition RPAREN instruction . ELSE instruction

    ELSE  décalage et aller à l'état 141

    $défaut  réduction par utilisation de la règle 33 (selection)


état 137

   35 selection: SWITCH LPAREN expression RPAREN LBRACE . switch_block RBRACE

    CASE     décalage et aller à l'état 142
    DEFAULT  décalage et aller à l'état 143

    $défaut  réduction par utilisation de la règle 36 (switch_block)

    switch_block  aller à l'état 144
    cases         aller à l'état 145


état 138

   54 expression: IDENTIFICATEUR LPAREN liste_expressions RPAREN .

    $défaut  réduction par utilisation de la règle 54 (expression)


état 139

   31 iteration: FOR LPAREN affectation SEMICOLON condition SEMICOLON . affectation RPAREN instruction

    IDENTIFICATEUR  décalage et aller à l'état 82

    affectation  aller à l'état 146
    variable     aller à l'état 60


état 140

   58 condition: NOT LPAREN condition RPAREN .

    $défaut  réduction par utilisation de la règle 58 (condition)


état 141

   34 selection: IF LPAREN condition RPAREN instruction ELSE . instruction

    IDENTIFICATEUR  décalage et aller à l'état 44
    FOR             décalage et aller à l'état 45
    WHILE           décalage et aller à l'état 46
    IF              décalage et aller à l'état 47
    SWITCH          décalage et aller à l'état 48
    BREAK           décalage et aller à l'état 49
    RETURN          décalage et aller à l'état 50

    $défaut  réduction par utilisation de la règle 29 ($@3)

    instruction  aller à l'état 147
    $@3          aller à l'état 54
    iteration    aller à l'état 55
    selection    aller à l'état 56
    appel        aller à l'état 57
    saut         aller à l'état 58
    affectation  aller à l'état 59
    variable     aller à l'état 60


état 142

   39 cases: CASE . CONSTANTE COLON instruction cases
   40      | CASE . CONSTANTE COLON instruction

    CONSTANTE  décalage et aller à l'état 148


état 143

   38 switch_block: DEFAULT . COLON instruction

    COLON  décalage et aller à l'état 149


état 144

   35 selection: SWITCH LPAREN expression RPAREN LBRACE switch_block . RBRACE

    RBRACE  décalage et aller à l'état 150


état 145

   37 switch_block: cases .

    $défaut  réduction par utilisation de la règle 37 (switch_block)


état 146

   31 iteration: FOR LPAREN affectation SEMICOLON condition SEMICOLON affectation . RPAREN instruction

    RPAREN  décalage et aller à l'état 151


état 147

   34 selection: IF LPAREN condition RPAREN instruction ELSE instruction .

    $défaut  réduction par utilisation de la règle 34 (selection)


état 148

   39 cases: CASE CONSTANTE . COLON instruction cases
   40      | CASE CONSTANTE . COLON instruction

    COLON  décalage et aller à l'état 152


état 149

   38 switch_block: DEFAULT COLON . instruction

    IDENTIFICATEUR  décalage et aller à l'état 44
    FOR             décalage et aller à l'état 45
    WHILE           décalage et aller à l'état 46
    IF              décalage et aller à l'état 47
    SWITCH          décalage et aller à l'état 48
    BREAK           décalage et aller à l'état 49
    RETURN          décalage et aller à l'état 50

    $défaut  réduction par utilisation de la règle 29 ($@3)

    instruction  aller à l'état 153
    $@3          aller à l'état 54
    iteration    aller à l'état 55
    selection    aller à l'état 56
    appel        aller à l'état 57
    saut         aller à l'état 58
    affectation  aller à l'état 59
    variable     aller à l'état 60


état 150

   35 selection: SWITCH LPAREN expression RPAREN LBRACE switch_block RBRACE .

    $défaut  réduction par utilisation de la règle 35 (selection)


état 151

   31 iteration: FOR LPAREN affectation SEMICOLON condition SEMICOLON affectation RPAREN . instruction

    IDENTIFICATEUR  décalage et aller à l'état 44
    FOR             décalage et aller à l'état 45
    WHILE           décalage et aller à l'état 46
    IF              décalage et aller à l'état 47
    SWITCH          décalage et aller à l'état 48
    BREAK           décalage et aller à l'état 49
    RETURN          décalage et aller à l'état 50

    $défaut  réduction par utilisation de la règle 29 ($@3)

    instruction  aller à l'état 154
    $@3          aller à l'état 54
    iteration    aller à l'état 55
    selection    aller à l'état 56
    appel        aller à l'état 57
    saut         aller à l'état 58
    affectation  aller à l'état 59
    variable     aller à l'état 60


état 152

   39 cases: CASE CONSTANTE COLON . instruction cases
   40      | CASE CONSTANTE COLON . instruction

    IDENTIFICATEUR  décalage et aller à l'état 44
    FOR             décalage et aller à l'état 45
    WHILE           décalage et aller à l'état 46
    IF              décalage et aller à l'état 47
    SWITCH          décalage et aller à l'état 48
    BREAK           décalage et aller à l'état 49
    RETURN          décalage et aller à l'état 50

    $défaut  réduction par utilisation de la règle 29 ($@3)

    instruction  aller à l'état 155
    $@3          aller à l'état 54
    iteration    aller à l'état 55
    selection    aller à l'état 56
    appel        aller à l'état 57
    saut         aller à l'état 58
    affectation  aller à l'état 59
    variable     aller à l'état 60


état 153

   38 switch_block: DEFAULT COLON instruction .

    $défaut  réduction par utilisation de la règle 38 (switch_block)


état 154

   31 iteration: FOR LPAREN affectation SEMICOLON condition SEMICOLON affectation RPAREN instruction .

    $défaut  réduction par utilisation de la règle 31 (iteration)


état 155

   39 cases: CASE CONSTANTE COLON instruction . cases
   40      | CASE CONSTANTE COLON instruction .

    CASE  décalage et aller à l'état 142

    $défaut  réduction par utilisation de la règle 40 (cases)

    cases  aller à l'état 156


état 156

   39 cases: CASE CONSTANTE COLON instruction cases .

    $défaut  réduction par utilisation de la règle 39 (cases)
