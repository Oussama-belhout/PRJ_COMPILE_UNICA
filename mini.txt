%{
	#include <stdio.h>
	#include "ast.h"
	#include "symtab.h"
	int yylex(void);  // Declare yylex to let the parser call it
	int yyerror(char const *msg);
	extern char *yytext;  // The text of the current token from the lexer
	extern const char * const yytoken_names[]; // Array of token names generated by Bison
	int stmt_list_count = 0;
	int nb_line=1;
	int col=1;
	AST *term;
	AST *stmt_list_buf[1024]; // simplistic static buffer
%}

%union {
    int integer;
    char *id;
    struct AST *ast;
    struct AST **ast_list;
}

%type <ast> programme
%type <ast> expression affectation instruction bloc variable

%token <id>IDENTIFICATEUR <integer>CONSTANTE VOID INT FOR WHILE IF ELSE SWITCH CASE DEFAULT
%token BREAK RETURN PLUS MOINS MUL DIV LSHIFT RSHIFT BAND BOR LAND LOR LT GT  
%token GEQ LEQ EQ NEQ NOT EXTERN 
%token LBRACE RBRACE LPAREN RPAREN COMMA LBRACKET RBRACKET SEMICOLON COLON
%left PLUS MOINS
%left MUL DIV
%left LSHIFT RSHIFT
%left BOR BAND
%left LAND LOR
%nonassoc THEN
%nonassoc ELSE
%left OP
%left REL
%start programme



//TODO 
// - review asendant grammar and their construction (with their grammar)
// - refactor grammar
// - start implementing features (identification, scoping ...)
// -- NOTE : il y aura beaucoup de propagations superflus entre les regles (qui serve pas a la construction du graphe mais AST)
// -- DEDUCTION : pas chaque noeud a l'AST sert a la production d'un noeud dans le fichier DOT 

%%
programme:
    liste_declarations liste_fonctions {
        term = ast_new_block(stmt_list_buf, stmt_list_count);
        ast_print_tree(term, "", true);
    }
;

liste_declarations:
	liste_declarations declaration
	|declaration_fonction
;

declaration_fonction:
	| declaration_fonction EXTERN type IDENTIFICATEUR LPAREN liste_parms RPAREN SEMICOLON
;

liste_fonctions:
	liste_fonctions fonction // $$ = $2
	|   fonction // $$ = 1
;

declaration:
	type liste_declarateurs SEMICOLON
;

liste_declarateurs:
	liste_declarateurs COMMA declarateur
	|   declarateur
;

declarateur:
	IDENTIFICATEUR
	|   declarateur LBRACKET CONSTANTE RBRACKET
;

fonction:
	type IDENTIFICATEUR LPAREN liste_parms RPAREN LBRACE liste_declarations liste_instructions RBRACE
;

type:
	VOID
	|   INT
;

liste_parms:
	liste_parms COMMA parm
	|parm
	|
;

parm:
	INT IDENTIFICATEUR
;

liste_instructions:
	liste_instructions instruction 
	|
;

instruction:
	iteration {}// $$ = 1 
	|   selection {}// $$ = 1
	|   saut {}// $$ = 1
	|   appel {}// $$ = 1
	|	affectation SEMICOLON  {
        stmt_list_buf[stmt_list_count++] = $1;
        $$ = $1;
    }
  	| 	bloc {
        stmt_list_buf[stmt_list_count++] = $1;
        $$ = $1;
    }
;

iteration:
	FOR LPAREN affectation SEMICOLON condition SEMICOLON affectation RPAREN instruction
	|   WHILE LPAREN condition RPAREN instruction
;

selection:
	IF LPAREN condition RPAREN instruction %prec THEN
	|   IF LPAREN condition RPAREN instruction ELSE instruction
	|   SWITCH LPAREN expression RPAREN LBRACE switch_block RBRACE
;
switch_block :
	|   cases 
	|   DEFAULT COLON instruction
;
cases : 
	CASE CONSTANTE COLON instruction cases
	| CASE CONSTANTE COLON instruction 
;

saut:
	BREAK SEMICOLON
	|   RETURN SEMICOLON
	|   RETURN expression SEMICOLON
;

affectation:
	variable OP expression {
        $$ = ast_new_aff($1, $3);
    }
;

bloc:
	LBRACE liste_declarations liste_instructions RBRACE {
        $$ = ast_new_block(stmt_list_buf, stmt_list_count);
        stmt_list_count = 0;
	}
;

appel:
	IDENTIFICATEUR LPAREN liste_expressions RPAREN SEMICOLON
;

variable:
    IDENTIFICATEUR {
        $$ = ast_new_id($1);
	}
	|   variable LBRACKET expression RBRACKET
;

expression:
	LPAREN expression RPAREN {}
	|   expression binary_op expression %prec OP {}
	|   MOINS expression{}
	|   CONSTANTE { $$ = ast_new_number($1)}
	|   variable { $$ = $1}
	|   IDENTIFICATEUR LPAREN liste_expressions RPAREN {}
;

liste_expressions:
	liste_expressions COMMA expression
	|expression
	|
;

condition:
	NOT LPAREN condition RPAREN
	|   condition binary_rel condition %prec REL
	|   LPAREN condition RPAREN
	|   expression binary_comp expression
;

binary_op:
	PLUS
	|   MOINS
	|   MUL
	|   DIV
	|   LSHIFT
	|   RSHIFT
	|   BAND
	|   BOR
;

binary_rel:
	LAND
	|   LOR
;

binary_comp:
	LT
	|   GT
	|   GEQ
	|   LEQ
	|   EQ
	|   NEQ
;

%%
int main()
{
	AST *term;
	yyparse();
}
int yywrap()
{}
int yyerror(const char *msg) 
{   
	printf("%s a la ligne %d colonne %d in front of %s\n", msg, nb_line, col, yytext);
  	return 0;
}