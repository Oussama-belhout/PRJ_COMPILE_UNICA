%{
	#include <stdio.h>
	#include "ast.h"
	#include "symtab.h"
	#include "graphgen.h"
	int yylex(void);  // Declare yylex to let the parser call it
	int yyerror(char const *msg);
	extern char *yytext;  // The text of the current token from the lexer
	extern const char * const yytoken_names[]; // Array of token names generated by Bison
	int nb_line=1;
	ParamEntry *params;
	int col=1;
	AST *ops[3]; 
	int ops_counter = 0;
	int param_counter = 0;
%}


%union { //         x {abr1 / integer i1} y{abr2 / string i2}
	struct ast_container {
		struct AST *ast;
		struct InstructEntry *instruct_entry;
		struct ParamEntry *param_entry;
		struct DimEntry *dim_entry;
		int ival;
		char *sval;
	}ast_container;


    int integer;
    char *str;
    struct AST *ast;
    struct AST **ast_list;
	struct ast_container ast_contain;
	struct ParamEntry *ParamEntry;
	struct CaseEntry *CaseEntry ;
	struct DimEntry *DimEntry;
	struct InstructEntry *InstructEntry;

}

%type <ast_contain> expression affectation appel saut instruction variable bloc var condition selection default_case switch_block iteration
%type <InstructEntry> liste_instructions
%type <ParamEntry> liste_expressions
%type <DimEntry> declarateur 
%type <CaseEntry> cases
%type <str> binary_comp binary_rel
%type <str> binary_op

%token <str>IDENTIFICATEUR <integer>CONSTANTE VOID INT FOR WHILE IF ELSE SWITCH CASE DEFAULT
%token BREAK RETURN <str>PLUS <str>MOINS <str>MUL <str>DIV <str>LSHIFT <str>RSHIFT <str>BAND <str>BOR <str>LAND <str>LOR <str>LT <str>GT  
%token <str>GEQ <str>LEQ <str>EQ <str>NEQ <str>NOT EXTERN 
%token LBRACE RBRACE LPAREN RPAREN COMMA LBRACKET RBRACKET SEMICOLON COLON
%left PLUS MOINS
%left MUL DIV
%left LSHIFT RSHIFT
%left BOR BAND
%left LAND LOR
%nonassoc THEN
%nonassoc ELSE
%left OP
%left REL
%start programme



//TODO 
// - review asendant grammar and their construction (with their grammar)
// - refactor grammar
// - start implementing features (identification, scoping ...)
// -- NOTE : il y aura beaucoup de propagations superflus entre les regles (qui serve pas a la construction du graphe mais AST)
// -- DEDUCTION : pas chaque noeud a l'AST sert a la production d'un noeud dans le fichier DOT 

%%
programme:
    liste_declarations liste_fonctions {

	}
;

liste_declarations:
	liste_declarations declaration
	|declaration_fonction
	
;

declaration_fonction:
	| declaration_fonction EXTERN type IDENTIFICATEUR LPAREN liste_parms RPAREN SEMICOLON
;

liste_fonctions:
	liste_fonctions fonction // $$ = $2
	|   fonction // $$ = 1
;

declaration:
	type liste_declarateurs SEMICOLON
;

liste_declarateurs:
	liste_declarateurs COMMA declarateur
	|   declarateur
;

declarateur:
	IDENTIFICATEUR {}
	|   declarateur LBRACKET CONSTANTE RBRACKET {

	}
;

fonction:
	type IDENTIFICATEUR LPAREN liste_parms RPAREN {enter_scope();printf("entering now scope-----\n"); } bloc {exit_scope();printf("reduced-exited function-scope main ---------\n");} // here we call 
	{
		FILE *dotfile = fopen("Graph.dot", "w");
		ast_to_dot(dotfile, $7.ast);
		fclose(dotfile);
		printf("now printing the whole tree \n");
        //ast_print_tree(first_child_term, "", true);

	} //TODO verification s'il exist un return si le type EST INT !!!
;

type:
	VOID
	|   INT
;

liste_parms:
	liste_parms COMMA parm
	|parm
	|
;

parm:
	INT IDENTIFICATEUR
;

liste_instructions:
	instruction liste_instructions {/*
		InstructEntry *instr_entry = malloc(sizeof(InstructEntry));
		InstructEntry *curr_bloc_instructs = get_bloc_instructs();
		instr_entry->instruct = first_child_term;
		instr_entry->next = curr_bloc_instructs->next;
		curr_bloc_instructs->next = instr_entry;

		InstructEntry *curr_bloc_instructs = get_xbloc_instructs(); 

		if (!instr_entry) {
			printf("Error: malloc failed in add_bloc_instr\n");
			return 0;
		}*/
        InstructEntry *instr_entry = malloc(sizeof(InstructEntry));
        printf("-- reducing instruction list one-by-one ");
        instr_entry->instruct = $1.ast;
        instr_entry->next = $2;
        //ast_print($1.ast);
		printf(", inst number : %d\n",ops_counter);
        $$ = instr_entry;
        ops_counter ++;


		//printf("just Added instruction to block\n");
}
	
	| {$$ = NULL;}
;

instruction:
	iteration {}// $$ = 1 
	|   selection {}// $$ = 1
	|   saut {}// $$ = 1
	|   appel {}// $$ = 1
	|	affectation SEMICOLON  {
			$$.ast = $1.ast;
			//ast_print($$.ast);
			//printf("just got the aff propagated to instruction\n");
    	}
	|	{enter_scope();} bloc {exit_scope();$$ = $2;}
	/*
  	| 	bloc {
        stmt_list_buf[stmt_list_count++] = $1;

        $$ = $1;
    }*/
;

iteration:
    FOR LPAREN affectation SEMICOLON condition SEMICOLON affectation RPAREN instruction {
        $$.ast = ast_new_for($3.ast, $5.ast, $7.ast, $9.ast);
    }
    | WHILE LPAREN condition RPAREN instruction {
        $$.ast = ast_new_while($3.ast, $5.ast);
    }
;

selection:
    IF LPAREN condition RPAREN instruction %prec THEN {
        $$.ast = ast_new_if($3.ast, $5.ast, NULL);
    }
    | IF LPAREN condition RPAREN instruction ELSE instruction {
        $$.ast = ast_new_if($3.ast, $5.ast, $7.ast);
    }
    | SWITCH LPAREN expression RPAREN LBRACE switch_block RBRACE {
        //$$.ast = ast_new_switch($3.ast, $6.ast, $6.ast);
    }
;

switch_block:
    cases default_case {/*
        $$.ast->data.AST_SWITCH.cases = $1;
        $$.ast->data.AST_SWITCH.default_case = $2.ast;*/
    }
;

cases:
    /* empty */ { $$ = NULL; }
    | cases CASE CONSTANTE COLON instruction {
        /*CaseEntry *case_entry = malloc(sizeof(CaseEntry));
        instr_entry->case = $3.ast;
        instr_entry->next = $1;
        $$ = case_entry;*/

    }
;

default_case:
    /* empty */ { $$.ast = NULL; }
    | DEFAULT COLON instruction {
        //$$.ast = $3.ast;
    }
;
appel:
	IDENTIFICATEUR LPAREN liste_expressions RPAREN SEMICOLON {
		$$.ast = ast_new_vlpt($1, $3, VLPT_FUNC_CALL);
	}
;
saut:
    BREAK SEMICOLON {
        $$.ast = ast_new_break();
    }
    | RETURN SEMICOLON {
        $$.ast = ast_new_return(NULL);
    }
    | RETURN expression SEMICOLON {
        $$.ast = ast_new_return($2.ast);
    }
;

// ---------------------------------
bloc: // TODO la rendre "LBRACE bloc_liste_declarations..."
	LBRACE liste_declarations  liste_instructions RBRACE {
        printf("reducing now bloc\n");
		$$.ast = ast_new_block($3);
		printf("this bloc has %d instructions",ops_counter);
		ast_print_tree($$.ast, "", true);
	}
;/*
bloc_liste_declarations : 
	liste_declarations 
	| bloc_declaration 
;

bloc_declaration:
	type bloc_liste_declarateurs SEMICOLON
;

bloc_liste_declarateurs:
	liste_declarateurs COMMA declarateur
	|   declarateur
bloc_inter_liste_declarations:
	bloc_inter_liste_declarations declaration	
;
;*/

// ---------------------------------
affectation:
	variable OP expression {
			$$.ast = ast_new_aff($1.ast, $3.ast);
			printf("just got the aff 	\n");
			ast_print($$.ast);
	}
;

// ---------------------------------
variable:
    var{
        if ($1.dim_entry != NULL) {
            $$.ast = ast_new_tab($1.dim_entry, $1.ast);
        } else {
            $$.ast = $1.ast;
        }
    }
;
var : 
	IDENTIFICATEUR {
        $$.ast = ast_new_id($1);
        $$.dim_entry = NULL;
    }
    | var LBRACKET expression RBRACKET {
        // Add new dimension at the end of the list
        DimEntry *entry = malloc(sizeof(DimEntry));
        entry->dim = $3.ast;
        entry->next = NULL;

        if ($1.dim_entry == NULL) {
            $$.dim_entry = entry;
        } else {
            // Find the last dimension and append
            DimEntry *last = $1.dim_entry;
            while (last->next) last = last->next;
            last->next = entry;
            $$.dim_entry = $1.dim_entry;
        }
        $$.ast = $1.ast; // propagate the base identifier
    }
;
// ---------------------------------
expression:
	LPAREN expression RPAREN { $$ = $2; }
	|   expression binary_op expression %prec OP {
			$$.ast = ast_new_binop($2, $1.ast, $3.ast);
			printf("reducing the bin op (%s) propagated to experession\n", (int)$2);
		}
	|   MOINS expression {$$.ast = ast_new_moins($2.ast);}
	|   CONSTANTE {
					$$.ast = ast_new_number($1);
					printf("we got to const : %d \n",$1);
					}
	|   variable {$$.ast = $1.ast;}
	|   IDENTIFICATEUR LPAREN liste_expressions RPAREN {

			$$.ast = ast_new_vlpt($1, $3, VLPT_FUNC_CALL);
		}
;

// liste_expressions as a left-recursive AST list (linked via AST_VLPT nodes)
liste_expressions:
    expression {
		ParamEntry *node = malloc(sizeof(ParamEntry));
		node->param = $1.ast ;
		node->next = $$ ;
		$$ = node;
        //$$.ast = $1.ast;

    }
    | liste_expressions COMMA expression {
	    ParamEntry *node = malloc(sizeof(ParamEntry));

		node->param = $3.ast ;
		node->next = $1 ;
		$$ = node;
		
    }
    | /* vide */ { $$ = NULL; }
;

condition:
	NOT LPAREN condition RPAREN {$$.ast = ast_new_moins($3.ast);}
	|   condition binary_rel condition %prec REL {
			$$.ast = ast_new_binop($2, $1.ast, $3.ast);
			printf("reducing the bin op (%s) propagated to experession\n", (int)$2);
	}
	|   LPAREN condition RPAREN {
			$$.ast = $2.ast ;
	}
	|   expression binary_comp expression{
			$$.ast = ast_new_binop($2, $1.ast, $3.ast);
			printf("reducing the bin op (%s) propagated to experession\n", (int)$2);
	}
;

binary_op:
	PLUS {$$ = $1;}
	|   MOINS {$$ = $1;}
	|   MUL {$$ = $1;}
	|   DIV {$$ = $1;} // Should be AST_DIV if you have it
	|   LSHIFT {$$ = $1;}
	|   RSHIFT {$$ = $1;}
	|   BAND {$$ = $1;}
	|   BOR {$$ = $1;}
;

binary_rel:
	LAND {$$ = $1;}
	|   LOR {$$ = $1;}
;

binary_comp:
	LT {$$ = $1;}
	|   GT {$$ = $1;}
	|   GEQ {$$ = $1;}
	|   LEQ {$$ = $1;}
	|   EQ {$$ = $1;}
	|   NEQ {$$ = $1;}
;

%%
int main()
{
	yyparse();

}
int yywrap()
{}
int yyerror(const char *msg) 
{   
	printf("%s a la ligne %d colonne %d in front of %s\n", msg, nb_line, col, yytext);
  	return 0;
}