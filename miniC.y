%{
	#include <stdio.h>
	int yylex(void);  // Declare yylex to let the parser call it
	int yyerror(char const *msg);
	extern char *yytext;  // The text of the current token from the lexer
	extern const char * const yytoken_names[]; // Array of token names generated by Bison
	int nb_line=1;
	int col=1;

%}
%token IDENTIFICATEUR CONSTANTE VOID INT FOR WHILE IF ELSE SWITCH CASE DEFAULT
%token BREAK RETURN PLUS MOINS MUL DIV LSHIFT RSHIFT BAND BOR LAND LOR LT GT  
%token GEQ LEQ EQ NEQ NOT EXTERN 
%token LBRACE RBRACE LPAREN RPAREN COMMA LBRACKET RBRACKET SEMICOLON COLON
%left PLUS MOINS
%left MUL DIV
%left LSHIFT RSHIFT
%left BOR BAND
%left LAND LOR
%nonassoc THEN
%nonassoc ELSE
%left OP
%left REL
%start programme
%union{
    int integer;
	float real;
    char *string;
}
//TODO 
// - review asendant grammar and their construction (with their grammar)
// - refactor grammar
// - start implementing features (identification, scoping ...)

%%
programme:
	liste_declarations liste_fonctions
;

liste_declarations:
	liste_declarations declaration
	|
;

liste_fonctions:
	liste_fonctions fonction
	|   fonction
;

declaration:
	type liste_declarateurs SEMICOLON
;

liste_declarateurs:
	liste_declarateurs COMMA declarateur
	|   declarateur
;

declarateur:
	IDENTIFICATEUR
	|   declarateur LBRACKET CONSTANTE RBRACKET
;

fonction:
	type IDENTIFICATEUR LPAREN liste_parms RPAREN LBRACE liste_declarations liste_instructions RBRACE
	|   EXTERN type IDENTIFICATEUR LPAREN liste_parms RPAREN SEMICOLON
;

type:
	VOID
	|   INT
;

liste_parms:
	liste_parms COMMA parm
	|parm
	|
;

parm:
	INT IDENTIFICATEUR
;

liste_instructions:
	liste_instructions instruction
	|
;

instruction:
	iteration
	|   selection
	|   saut
	|   affectation SEMICOLON
	|   bloc
	|   appel
;

iteration:
	FOR LPAREN affectation SEMICOLON condition SEMICOLON affectation RPAREN instruction
	|   WHILE LPAREN condition RPAREN instruction
;

selection:
	IF LPAREN condition RPAREN instruction %prec THEN
	|   IF LPAREN condition RPAREN instruction ELSE instruction
	|   SWITCH LPAREN expression RPAREN instruction
	|   CASE CONSTANTE COLON instruction
	|   DEFAULT COLON instruction
;

saut:
	BREAK SEMICOLON
	|   RETURN SEMICOLON
	|   RETURN expression SEMICOLON
;

affectation:
	variable OP expression
;

bloc:
	LBRACE liste_declarations liste_instructions RBRACE
;

appel:
	IDENTIFICATEUR LPAREN liste_expressions RPAREN SEMICOLON
;

variable:
	IDENTIFICATEUR
	|   variable LBRACKET expression RBRACKET
;

expression:
	LPAREN expression RPAREN
	|   expression binary_op expression %prec OP
	|   MOINS expression
	|   CONSTANTE
	|   variable
	|   IDENTIFICATEUR LPAREN liste_expressions RPAREN
;

liste_expressions:
	liste_expressions COMMA expression
	|expression
	|
;

condition:
	NOT LPAREN condition RPAREN
	|   condition binary_rel condition %prec REL
	|   LPAREN condition RPAREN
	|   expression binary_comp expression
;

binary_op:
	PLUS
	|   MOINS
	|   MUL
	|   DIV
	|   LSHIFT
	|   RSHIFT
	|   BAND
	|   BOR
;

binary_rel:
	LAND
	|   LOR
;

binary_comp:
	LT
	|   GT
	|   GEQ
	|   LEQ
	|   EQ
	|   NEQ
;
;
%%
int main()
{
yyparse();
}
int yywrap()
{}
int yyerror(const char *msg) 
{   
	printf("%s a la ligne %d colonne %d in front of %s\n", msg, nb_line, col, yytext);
  	return 0;
}