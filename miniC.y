%{
	#include <stdio.h>
	#include "ast.h"
	#include "symtab.h"
	int yylex(void);  // Declare yylex to let the parser call it
	int yyerror(char const *msg);
	extern char *yytext;  // The text of the current token from the lexer
	extern const char * const yytoken_names[]; // Array of token names generated by Bison
	int nb_line=1;
	int col=1;
	AST *ops[3]; 
	int ops_counter = 0;
%}

%union {
	struct ast_container {
		struct AST *ast;
		int someting ;
	}ast_container;

    int integer;
    char *str;
    struct AST *ast;
    struct AST **ast_list;
	struct ast_container ast_contain;
	struct InstructEntry *InstructEntry;
}

%type <ast_contain> expression affectation instruction variable bloc 
%type <InstructEntry> liste_instructions
%type <ast_contain> liste_expressions
%type <str> binary_comp binary_rel
%type <str> binary_op

%token <str>IDENTIFICATEUR <integer>CONSTANTE VOID INT FOR WHILE IF ELSE SWITCH CASE DEFAULT
%token BREAK RETURN <str>PLUS <str>MOINS <str>MUL <str>DIV <str>LSHIFT <str>RSHIFT <str>BAND <str>BOR <str>LAND <str>LOR <str>LT <str>GT  
%token <str>GEQ <str>LEQ <str>EQ <str>NEQ <str>NOT EXTERN 
%token LBRACE RBRACE LPAREN RPAREN COMMA LBRACKET RBRACKET SEMICOLON COLON
%left PLUS MOINS
%left MUL DIV
%left LSHIFT RSHIFT
%left BOR BAND
%left LAND LOR
%nonassoc THEN
%nonassoc ELSE
%left OP
%left REL
%start programme



//TODO 
// - review asendant grammar and their construction (with their grammar)
// - refactor grammar
// - start implementing features (identification, scoping ...)
// -- NOTE : il y aura beaucoup de propagations superflus entre les regles (qui serve pas a la construction du graphe mais AST)
// -- DEDUCTION : pas chaque noeud a l'AST sert a la production d'un noeud dans le fichier DOT 

%%
programme:
    liste_declarations liste_fonctions {}
;

liste_declarations:
	liste_declarations declaration
	|declaration_fonction
	
;

declaration_fonction:
	| declaration_fonction EXTERN type IDENTIFICATEUR LPAREN liste_parms RPAREN SEMICOLON
;

liste_fonctions:
	liste_fonctions fonction // $$ = $2
	|   fonction // $$ = 1
;

declaration:
	type liste_declarateurs SEMICOLON
;

liste_declarateurs:
	liste_declarateurs COMMA declarateur
	|   declarateur
;

declarateur:
	IDENTIFICATEUR
	|   declarateur LBRACKET CONSTANTE RBRACKET
;

fonction:
	type IDENTIFICATEUR LPAREN liste_parms RPAREN {enter_scope();printf("entering now scope-----\n"); } bloc {exit_scope();printf("reduced-exited function-scope main ---------\n");} // here we call 
	{
		printf("now printing the whole tree \n");
        ast_print_tree(first_child_term, "", true);

	} //TODO verification s'il exist un return si le type EST INT !!!
;

type:
	VOID
	|   INT
;

liste_parms:
	liste_parms COMMA parm
	|parm
	|
;

parm:
	INT IDENTIFICATEUR
;

liste_instructions:
	instruction liste_instructions {/*
		InstructEntry *instr_entry = malloc(sizeof(InstructEntry));
		InstructEntry *curr_bloc_instructs = get_bloc_instructs();
		instr_entry->instruct = first_child_term;
		instr_entry->next = curr_bloc_instructs->next;
		curr_bloc_instructs->next = instr_entry;

		InstructEntry *curr_bloc_instructs = get_bloc_instructs(); 

		if (!instr_entry) {
			printf("Error: malloc failed in add_bloc_instr\n");
			return 0;
		}*/
        InstructEntry *instr_entry = malloc(sizeof(InstructEntry));
        printf("-- reducing instruction list one-by-one\n");
        instr_entry->instruct = $1.ast;
        instr_entry->next = $2;
        ast_print($1.ast);
        $$ = instr_entry;
        ops_counter ++;


		//printf("just Added instruction to block\n");
}
	
	| {$$ = NULL;}
;

instruction:
	iteration {}// $$ = 1 
	|   selection {}// $$ = 1
	|   saut {}// $$ = 1
	|   appel {}// $$ = 1
	|	affectation SEMICOLON  {
			$$.ast = $1.ast;
			//ast_print($$.ast);
			//printf("just got the aff propagated to instruction\n");
    	}
	|	{enter_scope();} bloc {exit_scope();$$ = $2;}
	/*
  	| 	bloc {
        stmt_list_buf[stmt_list_count++] = $1;

        $$ = $1;
    }*/
;

iteration:
	FOR LPAREN affectation SEMICOLON condition SEMICOLON affectation RPAREN instruction
	|   WHILE LPAREN condition RPAREN instruction
;

selection:
	IF LPAREN condition RPAREN instruction %prec THEN
	|   IF LPAREN condition RPAREN instruction ELSE instruction
	|   SWITCH LPAREN expression RPAREN LBRACE switch_block RBRACE
;
switch_block :
	|   cases 
	|   DEFAULT COLON instruction
;
cases : 
	CASE CONSTANTE COLON instruction cases
	| CASE CONSTANTE COLON instruction 
;
appel:
	IDENTIFICATEUR LPAREN liste_expressions RPAREN SEMICOLON
;
saut:
	BREAK SEMICOLON // TODO : Verification sementique que c'est appelÃ© dans une boucle ou switch
	|   RETURN SEMICOLON
	|   RETURN expression SEMICOLON
;

// ---------------------------------
bloc:
	LBRACE liste_declarations  liste_instructions RBRACE {
        printf("reducing now bloc\n");
		$$.ast = ast_new_block($3);
		printf("this bloc has %d instructions",ops_counter);
		ast_print_tree($$.ast, "", true);
	}
;
// ---------------------------------
affectation:
	variable OP expression {
			$$.ast = ast_new_aff($1.ast, $3.ast);
			printf("just got the aff 	\n");
			ast_print($$.ast);
	}
;
// ---------------------------------
variable:
    IDENTIFICATEUR {
        //$$ = ast_new_id($1);
		$$.ast = ast_new_id($1);
		printf("just got the id %s \n",$1);
		//ast_print($$.ast);
	}
	|   variable LBRACKET expression RBRACKET
;
// ---------------------------------
expression:
	LPAREN expression RPAREN { $$ = $2; }
	|   expression binary_op expression %prec OP {
			$$.ast = ast_new_binop($2, $1.ast, $3.ast);
			printf("reducing the bin op (%d) propagated to experession\n", (int)$2);
		}
	|   MOINS expression {$$.ast = ast_new_moins($2.ast);}
	|   CONSTANTE {
					$$.ast = ast_new_number($1);
					printf("we got to const : %d \n",$1);
					}
	|   variable {$$.ast = $1.ast;}
	|   IDENTIFICATEUR LPAREN liste_expressions RPAREN {
			$$.ast = ast_new_vlpt($1, $3.ast, VLPT_FUNC_CALL);
		}
;

// liste_expressions as a left-recursive AST list (linked via AST_VLPT nodes)
liste_expressions:
    expression {
        $$.ast = ast_new_vlpt(NULL, $1.ast, 0);
    }
    | liste_expressions COMMA expression {
        AST *new_param = ast_new_vlpt(NULL, $3.ast, 0);
        new_param->data.AST_VLPT.params = $1.ast; // chain the list
        $$.ast = new_param;
    }
    | /* vide */ { $$.ast = NULL; }
;

condition:
	NOT LPAREN condition RPAREN
	|   condition binary_rel condition %prec REL
	|   LPAREN condition RPAREN
	|   expression binary_comp expression
;

binary_op:
	PLUS {$$ = $1;}
	|   MOINS {$$ = $1;}
	|   MUL {$$ = $1;}
	|   DIV {$$ = $1;} // Should be AST_DIV if you have it
	|   LSHIFT {$$ = $1;}
	|   RSHIFT {$$ = $1;}
	|   BAND {$$ = $1;}
	|   BOR {$$ = $1;}
;

binary_rel:
	LAND {$$ = $1;}
	|   LOR {$$ = $1;}
;

binary_comp:
	LT {$$ = $1;}
	|   GT {$$ = $1;}
	|   GEQ {$$ = $1;}
	|   LEQ {$$ = $1;}
	|   EQ {$$ = $1;}
	|   NEQ {$$ = $1;}
;

%%
int main()
{
	yyparse();
}
int yywrap()
{}
int yyerror(const char *msg) 
{   
	printf("%s a la ligne %d colonne %d in front of %s\n", msg, nb_line, col, yytext);
  	return 0;
}