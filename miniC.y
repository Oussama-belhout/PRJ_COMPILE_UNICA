%{
	#include <stdio.h>
    #include <stdbool.h>
	#include "ast.h"
	#include "symtab.h"
	#include "graphgen.h"
	int yylex(void);  // Declare yylex to let the parser call it
	int yyerror(char const *msg);
	extern char *yytext;  // The text of the current token from the lexer
	extern const char * const yytoken_names[]; // Array of token names generated by Bison
	int nb_line=1;
	ParamEntry *params;
	int col=1;
    bool empty_return = false ;
	int ops_counter = 0;
	int param_counter = 0;
    int func_counter = 0 ;

    void ast_to_dot_rec(FILE *f, struct AST *node, int parent_id, const char *edge_label);
%}


%union { //         x {abr1 / integer i1} y{abr2 / string i2}
	struct ast_container {
		struct AST *ast;
		struct InstructEntry *instruct_entry;
		struct ParamEntry *param_entry;
		struct DimEntry *dim_entry;
		int ival;
		char *sval;
	}ast_container;
    struct {
        struct CaseEntry *cases;
        struct AST *default_case;
    } switch_block_info;

    int integer;
    char *str;
    struct AST *ast;
    struct AST **ast_list;
	struct ast_container ast_contain;
	
	struct InstructEntry *InstructEntry;
	struct ParamEntry *ParamEntry;
	struct FuncEntry *FuncEntry;
	struct CaseEntry *CaseEntry ;
	struct DimEntry *DimEntry;

}

%type <ast_contain> expression affectation appel fonction saut instruction variable bloc var condition selection default_case  iteration
%type <InstructEntry> liste_instructions
%type <ParamEntry> liste_expressions
%type <DimEntry> declarateur 
%type <FuncEntry> liste_fonctions
%type <CaseEntry> cases
%type <str> binary_comp binary_rel
%type <str> binary_op type
%type <switch_block_info> switch_block

%token <str>IDENTIFICATEUR <integer>CONSTANTE VOID INT FOR WHILE IF ELSE SWITCH CASE DEFAULT
%token BREAK RETURN <str>PLUS <str>MOINS <str>MUL <str>DIV <str>LSHIFT <str>RSHIFT <str>BAND <str>BOR <str>LAND <str>LOR <str>LT <str>GT  
%token <str>GEQ <str>LEQ <str>EQ <str>NEQ <str>NOT EXTERN 
%token LBRACE RBRACE LPAREN RPAREN COMMA LBRACKET RBRACKET SEMICOLON COLON
%left PLUS MOINS
%left MUL DIV
%left LSHIFT RSHIFT
%left BOR BAND
%left LAND LOR
%nonassoc THEN
%nonassoc ELSE
%left OP
%left REL
%start programme


			
//TODO 
// - review asendant grammar and their construction (with their grammar)
// - refactor grammar
// - start implementing features (identification, scoping ...)
// -- NOTE : il y aura beaucoup de propagations superflus entre les regles (qui serve pas a la construction du graphe mais AST)
// -- DEDUCTION : pas chaque noeud a l'AST sert a la production d'un noeud dans le fichier DOT 

%%
programme:
    liste_declarations liste_fonctions {
		//transpile($2);
	}
;

liste_declarations:
	liste_declarations declaration
	|declaration_fonction
	
;

declaration_fonction:
	| declaration_fonction EXTERN type IDENTIFICATEUR LPAREN liste_parms RPAREN SEMICOLON
;
liste_fonctions:
    fonction {

    }
    | liste_fonctions fonction {}
;
/*
liste_fonctions:
    fonction {
        // Create the head of the list for a single expression
        FuncEntry *node = malloc(sizeof(FuncEntry));
        if (node) {
            node->function = $1.ast;
            node->next = NULL; // This is the end of the list
            $$ = node;
            param_counter++;
        } else {
            // Handle malloc failure
            yyerror("Memory allocation failed for Function entry\n");
            $$ = NULL;
        }
    }
    | liste_fonctions fonction {
        // Append the new expression to the existing list ($1)
        FuncEntry *new_param = malloc(sizeof(FuncEntry));
        if (new_param) {
            new_param->function = $2.ast;
            new_param->next = NULL; // This new param will be the new tail

            // Find the current tail of the list ($1) and append new_param
            FuncEntry *current = $1;
            if (current == NULL) { // Should not happen if this rule is reached with non-empty liste_expressions
                $$ = new_param;
            } else {
                while (current->next != NULL) {
                    current = current->next;
                }
                current->next = new_param;
                $$ = $1; // The head of the list remains $1
            }
            param_counter++;
        } else {
            // Handle malloc failure
            yyerror("Memory allocation failed for Function Entry\n");
            $$ = $1; // Keep the existing list if allocation fails
        }
    }
;*/

declaration:
	type liste_declarateurs SEMICOLON
;

liste_declarateurs:
	liste_declarateurs COMMA declarateur
	|   declarateur
;

declarateur:
	IDENTIFICATEUR {}
	|   declarateur LBRACKET CONSTANTE RBRACKET {

	}
;

fonction:
    type IDENTIFICATEUR LPAREN liste_parms RPAREN {enter_scope(); printf("entering now scope-----\n"); } bloc {exit_scope(); printf("reduced-exited function-scope main ---------\n");}
    {
        // Open the DOT file in append mode (or create a new one for each function if you prefer)
        FILE *dotfile = fopen("Graph.dot", "a");

        if (!dotfile) {
            fprintf(stderr, "Cannot open Graph.dot for writing\n");
        } else {
            // Unique root node for this function
            static int func_root_counter = 0;
            int root_id = 10000 + func_root_counter++; // Large number to avoid collision

            // Print the root node as a blue downward trapezoid

            // Connect the root to the function AST
            // $6.ast is the function body (AST_BLOCK), so create a temporary AST_FUNC node if needed
            AST *func_root = ast_new_func($1, ast_new_id($2), $7.ast);

            // Generate the DOT for the function body, with the root as parent
            ast_to_dot_rec(dotfile, func_root, -1, NULL);

            // Optionally, free func_root if you don't need it elsewhere
            free(func_root);

            fclose(dotfile);
        }
    } //TODO verification s'il exist un return si le type EST INT !!!
;

type:
    VOID { $$ = "void"; }
    | INT { $$ = "int"; }
;

liste_parms:
	liste_parms COMMA parm
	|parm
	|
;

parm:
	INT IDENTIFICATEUR
;

liste_instructions:
	instruction liste_instructions {/*
		InstructEntry *instr_entry = malloc(sizeof(InstructEntry));
		InstructEntry *curr_bloc_instructs = get_bloc_instructs();
		instr_entry->instruct = first_child_term;
		instr_entry->next = curr_bloc_instructs->next;
		curr_bloc_instructs->next = instr_entry;

		InstructEntry *curr_bloc_instructs = get_xbloc_instructs(); 

		if (!instr_entry) {
			printf("Error: malloc failed in add_bloc_instr\n");
			return 0;
		}*/
        InstructEntry *instr_entry = malloc(sizeof(InstructEntry));
        printf("-- reducing instruction list one-by-one ");
        instr_entry->instruct = $1.ast;
        instr_entry->next = $2;
        //ast_print($1.ast);
		printf(", inst number : %d\n",ops_counter);
        $$ = instr_entry;
        ops_counter ++;


		//printf("just Added instruction to block\n");
}
	
	| {$$ = NULL;}
;

instruction:
	iteration {}// $$ = 1 
	|   selection {}// $$ = 1
	|   saut {}// $$ = 1
	|   appel {}// $$ = 1
	|	affectation SEMICOLON  {
			$$.ast = $1.ast;
			//ast_print($$.ast);
			//printf("just got the aff propagated to instruction\n");
    	}
	|	{enter_scope();} bloc {exit_scope();$$ = $2;}
	/*
  	| 	bloc {
        stmt_list_buf[stmt_list_count++] = $1;

        $$ = $1;
    }*/
;

iteration:
    FOR LPAREN affectation SEMICOLON condition SEMICOLON affectation RPAREN instruction {
        $$.ast = ast_new_for($3.ast, $5.ast, $7.ast, $9.ast);
    }
    | WHILE LPAREN condition RPAREN instruction {
        $$.ast = ast_new_while($3.ast, $5.ast);
    }
;

selection:
    IF LPAREN condition RPAREN instruction %prec THEN {
        $$.ast = ast_new_if($3.ast, $5.ast, NULL);
    }
    | IF LPAREN condition RPAREN instruction ELSE instruction {
        $$.ast = ast_new_if($3.ast, $5.ast, $7.ast);
    }
    | SWITCH LPAREN expression RPAREN LBRACE switch_block RBRACE {
        $$.ast = ast_new_switch($3.ast, $6.cases, $6.default_case);
    }
;

switch_block:
    cases default_case {
        $$.cases = $1;
        $$.default_case = $2.ast;
    }
;

cases:
    /* empty */ { $$ = NULL; }
    | cases CASE CONSTANTE COLON instruction {
        $$ = case_entry_new(ast_new_number($3), $5.ast, $1);
    }
;

default_case:
    /* empty */ { $$.ast = NULL; }
    | DEFAULT COLON instruction { $$.ast = $3.ast; }
;
appel:
	IDENTIFICATEUR LPAREN liste_expressions RPAREN SEMICOLON {
		$$.ast = ast_new_vlpt($1, $3, VLPT_FUNC_CALL);
	}
;
saut:
    BREAK SEMICOLON {
        $$.ast = ast_new_break();
    }
    | RETURN SEMICOLON {
        $$.ast = ast_new_return(NULL);
        empty_return = true ;
    }
    | RETURN expression SEMICOLON {
        $$.ast = ast_new_return($2.ast);
    }
;

// ---------------------------------
bloc: // TODO la rendre "LBRACE bloc_liste_declarations..." pour la possiblitÃ© de declaration au deb bloc
	LBRACE liste_declarations  liste_instructions RBRACE {
        printf("reducing now bloc\n");
		$$.ast = ast_new_block($3);
		printf("this bloc has %d instructions",ops_counter);
		//ast_print_tree($$.ast, "", true);
	}
;/*
bloc_liste_declarations : 
	liste_declarations 
	| bloc_declaration 
;

bloc_declaration:
	type bloc_liste_declarateurs SEMICOLON
;

bloc_liste_declarateurs:
	liste_declarateurs COMMA declarateur
	|   declarateur
bloc_inter_liste_declarations:
	bloc_inter_liste_declarations declaration	
;
;*/

// ---------------------------------
affectation:
	variable OP expression {
			$$.ast = ast_new_aff($1.ast, $3.ast);
			printf("just got the aff 	\n");
			ast_print($$.ast);
	}
;

// ---------------------------------
variable:
    var{
        if ($1.dim_entry != NULL) {
            $$.ast = ast_new_tab($1.dim_entry, $1.ast);
        } else {
            $$.ast = $1.ast;
        }
    }
;
var : 
	IDENTIFICATEUR {
        $$.ast = ast_new_id($1);
        $$.dim_entry = NULL;
    }
    | var LBRACKET expression RBRACKET {
        // Add new dimension at the end of the list
        DimEntry *entry = malloc(sizeof(DimEntry));
        entry->dim = $3.ast;
        entry->next = NULL;

        if ($1.dim_entry == NULL) {
            $$.dim_entry = entry;
        } else {
            // Find the last dimension and append
            DimEntry *last = $1.dim_entry;
            while (last->next) last = last->next;
            last->next = entry;
            $$.dim_entry = $1.dim_entry;
        }
        $$.ast = $1.ast; // propagate the base identifier
    }
;
// ---------------------------------
expression:
	LPAREN expression RPAREN { $$ = $2; }
	|   expression binary_op expression %prec OP {
			$$.ast = ast_new_binop($2, $1.ast, $3.ast);
			printf("reducing the bin op (%s) propagated to experession\n", (int)$2);
		}
	|   MOINS expression {$$.ast = ast_new_moins($2.ast);}
	|   CONSTANTE {
					$$.ast = ast_new_number($1);
					printf("we got to const : %d \n",$1);
					}
	|   variable {$$.ast = $1.ast;}
	|   IDENTIFICATEUR LPAREN liste_expressions RPAREN {

			$$.ast = ast_new_vlpt($1, $3, VLPT_FUNC_CALL);
			printf("added %d params to the function call of %s ---------------\n",param_counter,$1);
			param_counter = 0;

		}
;

// liste_expressions as a left-recursive AST list (linked via AST_VLPT nodes)
/*liste_expressions:
    expression {
		ParamEntry *node = malloc(sizeof(ParamEntry));
		node->param = $1.ast ;
		node->next = $$ ;
		$$ = node;
		param_counter ++ ;
        //$$.ast = $1.ast;

    }
    | liste_expressions COMMA expression {
	    ParamEntry *node = malloc(sizeof(ParamEntry));
		param_counter ++ ;
		node->param = $3.ast ;
		node->next = $1 ;
		$$ = node;
		
    }
    |  { $$ = NULL; }
;*/
liste_expressions:
    expression {
        // Create the head of the list for a single expression
        ParamEntry *node = malloc(sizeof(ParamEntry));
        if (node) {
            node->param = $1.ast;
            node->next = NULL; // This is the end of the list
            $$ = node;
            param_counter++;
        } else {
            // Handle malloc failure
            yyerror("Memory allocation failed for ParamEntry\n");
            $$ = NULL;
        }
    }
    | liste_expressions COMMA expression {
        // Append the new expression to the existing list ($1)
        ParamEntry *new_param = malloc(sizeof(ParamEntry));
        if (new_param) {
            new_param->param = $3.ast;
            new_param->next = NULL; // This new param will be the new tail

            // Find the current tail of the list ($1) and append new_param
            ParamEntry *current = $1;
            if (current == NULL) { // Should not happen if this rule is reached with non-empty liste_expressions
                $$ = new_param;
            } else {
                while (current->next != NULL) {
                    current = current->next;
                }
                current->next = new_param;
                $$ = $1; // The head of the list remains $1
            }
            param_counter++;
        } else {
            // Handle malloc failure
            yyerror("Memory allocation failed for ParamEntry\n");
            $$ = $1; // Keep the existing list if allocation fails
        }
    }
    | /* vide */ { $$ = NULL; }
;

condition:
	NOT LPAREN condition RPAREN {$$.ast = ast_new_moins($3.ast);}
	|   condition binary_rel condition %prec REL {
			$$.ast = ast_new_binop($2, $1.ast, $3.ast);
			printf("reducing the bin op (%s) propagated to experession\n", (int)$2);
	}
	|   LPAREN condition RPAREN {
			$$.ast = $2.ast ;
	}
	|   expression binary_comp expression{
			$$.ast = ast_new_binop($2, $1.ast, $3.ast);
			printf("reducing the bin op (%s) propagated to experession\n", (int)$2);
	}
;

binary_op:
	PLUS {$$ = $1;}
	|   MOINS {$$ = $1;}
	|   MUL {$$ = $1;}
	|   DIV {$$ = $1;} // Should be AST_DIV if you have it
	|   LSHIFT {$$ = $1;}
	|   RSHIFT {$$ = $1;}
	|   BAND {$$ = $1;}
	|   BOR {$$ = $1;}
;

binary_rel:
	LAND {$$ = $1;}
	|   LOR {$$ = $1;}
;

binary_comp:
	LT {$$ = $1;}
	|   GT {$$ = $1;}
	|   GEQ {$$ = $1;}
	|   LEQ {$$ = $1;}
	|   EQ {$$ = $1;}
	|   NEQ {$$ = $1;}
;

%%
int main()
{
    FILE *dotfile = fopen("Graph.dot", "w");
    fprintf(dotfile, "digraph AST {\n");
    fclose(dotfile);

	yyparse();

    FILE *f = fopen("Graph.dot", "a");
    fprintf(f, "}\n");
    fclose(f);
}
int yywrap()
{}
int yyerror(const char *msg) 
{   
	printf("%s a la ligne %d colonne %d in front of %s\n", msg, nb_line, col, yytext);
  	return 0;
}